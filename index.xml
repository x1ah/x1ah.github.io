<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>重案组之虎</title>
    <link>https://when.run/</link>
    <description>Recent content on 重案组之虎</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Wed, 13 Nov 2019 17:29:13 +0800</lastBuildDate>
    
	<atom:link href="https://when.run/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>关键字</title>
      <link>https://when.run/words/</link>
      <pubDate>Wed, 13 Nov 2019 17:29:13 +0800</pubDate>
      
      <guid>https://when.run/words/</guid>
      <description> 一闪而过的计算机名词
  Double check Copy On Write  </description>
    </item>
    
    <item>
      <title>Python2 迁移到 Python3 小事记</title>
      <link>https://when.run/posts/python2-to-python3/</link>
      <pubDate>Tue, 12 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://when.run/posts/python2-to-python3/</guid>
      <description>前期规划 在开始迁移前，需要大致盘点一下都会有哪些工作量，哪些代码需要做兼容，哪些服务需要做迁移。前期可以大概分成一下几部分：
 主项目（主要的项目，承担了主要的日常开发任务以及业务需求） 其他服务（为主项目服务的各个服务，如支付、IM、广告等） 依赖库，依赖又包括：  公司内部基础组件 第三方依赖   在列出所有的 &amp;ldquo;代码清单&amp;rdquo; 后，需要有个先后顺序，来逐步的进行迁移。首先上面提到的三个大点中，其他服务 其实优先级并不高，因为日常不怎么会开发，处于维护状态。因此保持正常运行即可，优先进行其他两项的迁移。而依赖库处处在引用，不提前进行 Python3 适配其他工作将无法进行。因此适配顺序如下：
 排查第三方依赖库，测试，升级到兼容 Python2/Python3 的版本 排查公司内部基础组件库，测试，兼容适配 Python2/Python3 进行主项目的代码层面适配，使用工具和一些库进行 2 和 3 的适配，使现有代码能同时在 2 和 3 下面跑。增加 py3 环境的单元测试。  在一切开始之前，还需要保证日常新加的代码不再引入不兼容的代码，因此应该提前使用 pre-commit 对每个 commit 进行检查，使用 pylint 进行兼容性检查，配置如下：
# .pre-commit-config.yaml - repo: https://github.com/xiachufang/mirrors-pylint rev: v1.9.2 hooks: - id: pylint args: - --py3k - --score=n  迁移中 迁移办法一般是先排查关键字，如 iteritems/itervalues/xrange 等，这些可以全部使用 six 相应方法直接替换。 除此之外，应该给单元测试增加 Python3 环境，这样首先保证单元测试能在 Python3 下跑通，在调通单元测试之后，如果测试覆盖率高，那么基本已经改完很大一部分代码了。在给代码做适配是，可以使用 futurize 来自动修改一些代码，减少一些重复工作。并且可以参考 futurize 的 Cheat Sheet: Writing Python 2-3 compatible code 来做对照，进行修改代码。</description>
    </item>
    
    <item>
      <title>About</title>
      <link>https://when.run/about/</link>
      <pubDate>Fri, 08 Nov 2019 13:05:26 +0800</pubDate>
      
      <guid>https://when.run/about/</guid>
      <description>&amp;ldquo;努力，奋斗&amp;rdquo;
 GitHub: x1ah Telegram: x1ahh QQ: x  </description>
    </item>
    
    <item>
      <title>我的收藏夹</title>
      <link>https://when.run/collects/</link>
      <pubDate>Fri, 08 Nov 2019 13:04:04 +0800</pubDate>
      
      <guid>https://when.run/collects/</guid>
      <description> 文章  Go Concurrency Patterns The Go scheduler Raft: Understandable Distributed Consensus Distributed systems  电影  《新龙门客栈》- 张家辉 《末代皇帝》- 尊龙 《哪吒之魔童降世》 《白蛇：缘起》 《阳光灿烂的日子》  </description>
    </item>
    
    <item>
      <title>向量时钟(Vector Clock)</title>
      <link>https://when.run/posts/vector-clock/</link>
      <pubDate>Fri, 08 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://when.run/posts/vector-clock/</guid>
      <description>向量时钟(Vector Clock) 向量时钟是在分布式系统中检测事件因果关系的一种算法。如图：系统中有 ABC 三个进程，每个进程都维护自己的一个向量时钟，时钟的规则如下： 1. 初始时，所有进程的时钟都为 0 2. 进程每次处理一个内部事件，其逻辑时钟加 1 3. 每次发送消息，其逻辑时钟加 1，并且将其向量时钟一起发送 4. 每次收到消息，其逻辑时钟加 1，并更新本地时钟，逻辑时钟的值为本地时钟里值的最大值
每个进程维护的所有逻辑时钟为一个向量时钟。假设进程 A 向量时钟如下：
+----+ |A:0 | |B:3 | ===&amp;gt; 这个整体称为 A 的 &amp;quot;向量时钟&amp;quot;，其中，A:0 为 A 的逻辑时钟 |C:5 | +----+  因果关系判断规则  如果时钟 V1 的每个逻辑时钟值都比时钟 V2 大，那么称 V1 比 V2 先发生。如： V1: [A:2,B:4,C:2] 与 V2: [A:1,B:2,C:1] 如果不满足条件 1), 即有的值 V1 比 V2 大，有的 V2 比 V1 大，那么看做两个事件同时发生  应用 向量时钟通常用于检测 replication 之间的数据冲突。例如 Dynamo: Data Versioning With DynamoDB。</description>
    </item>
    
    <item>
      <title>如何设计一个秒杀系统</title>
      <link>https://when.run/posts/miao-sha/</link>
      <pubDate>Wed, 02 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://when.run/posts/miao-sha/</guid>
      <description> 如何设计一个秒杀系统  总结极客时间专栏《如何设计一个秒杀系统》
 极客时间
问题 其实这类高并发问题，总结起来就是两点，并发读、 并发写。并且在这种情况下，系统还需要做到：
 高性能：支持并发读并发写 一致性：保证系统正确，如不发生超卖等 高可用：保证系统在极端条件下的可用性，PlanB 等  原则  数据尽量少：c-s 传输过程中，数据尽量少，减少传输时间 请求数尽量少：减少资源消耗 路径尽量短：请求会经过若干个中间件，经过的中间件应该尽量少，每个节点都可能会挂，最后整体可用性(&amp;lt;1)就是经过的所有节点可用性的乘积 依赖尽量少：指的是业务依赖（优惠券、用户信息等），防止主要服务被其他附属依赖给拖垮掉 不要有单点：单点就是整个系统中最弱的地方，很容易被击垮  动静分离 静态数据  统一 cache 层 CDN 代理服务器缓存  动态数据  业务隔离：必须参加活动需要提前报名，服务器对这些热点进行预热 系统隔离：秒杀系统单独部署，落到不同集群当中，避免拖垮其他服务 数据隔离：针对这些热点数据，比如启用单独的 cache 或 MySQL 实例  流量削峰 面对秒杀系统需要承受的海量流量，如果全部落到数据库上，那么数据库将不堪重负，因此可以进行分层的流量削峰：
 答题、验证码等，在客户端直接过滤，将流量摊平，而不是瞬时洪峰流量 服务端请求排队，请求到达了不即时返回，而是塞进队列里，FIFO 方式进行处理，然后异步通知客户端（体验不好，用户无法实时收到反馈） 分层校验，保证落到数据库的请求都是有效请求  减库存 减库存是最关键的一个逻辑，需要保证高并发的情况下，不会发生超售。常用的有三种减库存方案：
 下单减库存：下单就减库存，会产生非常多无效订单，体验不好。 付款减库存：可能会有用户在付款完成之后，结果提示没库存了。 预扣库存：用户下单后减库存，但是库存只有几分钟有效期，过了有效期就回收库存，体验较好。  PlanB 高可用系统的 PlanB，针对秒杀系统，可以做一些事，比如：
 降级：如系统容量到达一点程度之后，关闭一些非核心功能，把有限的资源让给核心功能 限流：在事先进行压力测试时，预估一个最高 QPS，并将其设为阈值，到达这个阈值之后，其他请求扔队列或者直接丢弃 拒绝服务：最坏的情况，达到某个临界点（CPU 90%）直接拒绝服务，保护服务，等负载下降之后恢复，避免被直接长时间拖垮。  </description>
    </item>
    
    <item>
      <title>我订阅的 RSS 源</title>
      <link>https://when.run/posts/rss-rec/</link>
      <pubDate>Tue, 01 Oct 2019 10:31:23 +0800</pubDate>
      
      <guid>https://when.run/posts/rss-rec/</guid>
      <description> 之前一直寻找好用的 RSS 订阅软件，起初试了 Reeder, 可是不能设置代理，同步速度让我捉急，后来发现 slack 有 RSS APP，因此转而使用 slack 订阅。slack 订阅很方便，免费的空间也够用。
 下面是我订阅的一些 RSS 源，备份一份以防丢失。
 面向信仰编程 - Articles 克鲁斯卡尔的博客 Techshack Weekly - issues JerryQu 的小站 有赞技术团队 Dave Cheney 美团技术团队 酷 壳 – CoolShell IBM Developer 中国 : Big data and analytics,Cloud computing,Internet of Things,Java technology,Open source,Web development : 技术文章,教程 云风的 BLOG The Go Programming Language Blog shonenada qcrao Posts on WKLKEN BUILDING  王垠的博客 - 当然我在扯淡 Instagram Engineering - Medium  效果图: </description>
    </item>
    
    <item>
      <title>Python 面试题整理[实习]</title>
      <link>https://when.run/posts/python-interview/</link>
      <pubDate>Fri, 28 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://when.run/posts/python-interview/</guid>
      <description>下面的内容均为最近几周找 Python 实习遇见的各种面试题，记录备用。其中有 bat 之类大厂也有十几个人的初创公司～（斜体的为遇见两次以上的。）
 Python 语法  说说你平时 Python 都用哪些库
 == 和 is 区别。
 == 是比较两对象的值，is 是比较在内存中的地址(id)， is 相当于 id(objx) == id(objy)。  深拷贝和浅拷贝。
  # 浅拷贝操作只会拷贝被拷贝对象的第一层对象，对于更深层级的只不过是拷贝其引用，如下例中 `a[2]` # 和 `lst[2]` 这两个对象为第二层，实际上浅拷贝之后，这两个还是一个对象。深拷贝会完全的拷贝被拷 # 贝对象的所有层级对象，也就是一个真正意义上的拷贝。 &amp;gt;&amp;gt;&amp;gt; from copy import copy, deepcopy &amp;gt;&amp;gt;&amp;gt; lst = [1, 2, [3, 4]] &amp;gt;&amp;gt;&amp;gt; a, b = copy(lst), deepcopy(lst) &amp;gt;&amp;gt;&amp;gt; a, b ([1, 2, [3, 4]], [1, 2, [3, 4]]) &amp;gt;&amp;gt;&amp;gt; id(lst[2]), id(a[2]), id(b[2]) (139842737414224, 139842737414224, 139842737414584) &amp;gt;&amp;gt;&amp;gt; lst[0] = 10 &amp;gt;&amp;gt;&amp;gt; a [1, 2, [3, 4]] &amp;gt;&amp;gt;&amp;gt; b [1, 2, [3, 4]] &amp;gt;&amp;gt;&amp;gt; lst[2][0] = &#39;test&#39; &amp;gt;&amp;gt;&amp;gt; lst [10, 2, [&#39;test&#39;, 4]] &amp;gt;&amp;gt;&amp;gt; a [1, 2, [&#39;test&#39;, 4]] &amp;gt;&amp;gt;&amp;gt; b [1, 2, [3, 4]]   __init__ 和 __new__。</description>
    </item>
    
    <item>
      <title>[转]如何编写无法维护的代码</title>
      <link>https://when.run/posts/unmain/</link>
      <pubDate>Sat, 01 Oct 2016 00:00:00 +0000</pubDate>
      
      <guid>https://when.run/posts/unmain/</guid>
      <description>永远不要（把自己遇到的问题）归因于（他人的）恶意，这恰恰说明了（你自己的）无能。 &amp;ndash; 拿破仑
 为了造福大众，在Java编程领域创造就业机会，兄弟我在此传授大师们的秘籍。这些大师写的代码极其难以维护，后继者就是想对它做最简单的修改都需要花上数年时间。而且，如果你能对照秘籍潜心修炼，你甚至可以给自己弄个铁饭碗，因为除了你之外，没人能维护你写的代码。再而且，如果你能练就秘籍中的全部招式，那么连你自己都无法维护你的代码了！
你不想练功过度走火入魔吧。那就不要让你的代码一眼看去就完全无法维护，只要它实质上是那样就行了。否则，你的代码就有被重写或重构的风险！
阅读全文</description>
    </item>
    
  </channel>
</rss>