<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Distributed on 重案组之虎</title>
    <link>https://when.run/tags/distributed/</link>
    <description>Recent content in Distributed on 重案组之虎</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Fri, 08 Nov 2019 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://when.run/tags/distributed/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>向量时钟(Vector Clock)</title>
      <link>https://when.run/posts/vector-clock/</link>
      <pubDate>Fri, 08 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://when.run/posts/vector-clock/</guid>
      <description> 顺序 在分布式系统中，“顺序” 是一个基石一样的存在，甚至在现实世界也是如此。进地铁需要排队、两个人同时抢最后一张火车票，必然有一个人先买到票，一个人买不到。 同样的，在分布式系统中，两个事件之间存在两种情况：1. 有先后顺序；2. 无先后顺序（看做同时发生）
假设存在这样一个系统：有多个 replication，每个 replication 都可以接收读、写请求。在某一时刻，两个 replication A 和 B 分别收到一条这样的请求，A: SET foo 1，B: SET foo 10。这时候两个节点的数据发生了冲突，那么该如何去解决这个冲突呢？
首先最简单的直观想法是，如果能区分出这两个请求的先后顺序，那么就能决定采用哪个请求的结果。但是如何区分两个请求的先后顺序，是一个问题。如果每个节点的写请求都同步到其他节点，保证了数据一致性，这时候如果其中一个节点挂了，这个同步过程将会阻塞直到节点恢复，这对我们来讲丢失了分区可用性，即牺牲了 P(Partition tolerance) 而保全了 CA。
时间 时间是顺序的一种实现，上面的问题，如果有个全局的时钟，那么也能根据事件发生的时间，来区分先后顺序。从而达到数据一致性。
向量时钟(Vector Clock) </description>
    </item>
    
  </channel>
</rss>