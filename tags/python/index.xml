<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on x1ah</title>
    <link>https://when.run/tags/python/</link>
    <description>Recent content in Python on x1ah</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <lastBuildDate>Tue, 12 Nov 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://when.run/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Python2 迁移到 Python3 规划和实施</title>
      <link>https://when.run/posts/python2-to-python3/</link>
      <pubDate>Tue, 12 Nov 2019 00:00:00 +0000</pubDate>
      
      <guid>https://when.run/posts/python2-to-python3/</guid>
      <description>前期规划 在开始迁移前，需要大致盘点一下都会有哪些工作量，哪些代码需要做兼容，哪些服务需要做迁移。前期可以大概分成一下几部分：
 主项目（主要的项目，承担了主要的日常开发任务以及业务需求） 其他服务（为主项目服务的各个服务，如支付、IM、广告等） 依赖库，依赖又包括：  公司内部基础组件 第三方依赖    在列出所有的 &amp;ldquo;代码清单&amp;rdquo; 后，需要有个先后顺序，来逐步的进行迁移。首先上面提到的三个大点中，其他服务 其实优先级并不高，因为日常不怎么会开发，处于维护状态。因此保持正常运行即可，优先进行其他两项的迁移。而依赖库处处在引用，不提前进行 Python3 适配其他工作将无法进行。因此适配顺序如下：
 排查第三方依赖库，测试，升级到兼容 Python2/Python3 的版本 排查公司内部基础组件库，测试，兼容适配 Python2/Python3 进行主项目的代码层面适配，使用工具和一些库进行 2 和 3 的适配，使现有代码能同时在 2 和 3 下面跑。增加 py3 环境的单元测试。  在一切开始之前，还需要保证日常新加的代码不再引入不兼容的代码，因此应该提前使用 pre-commit 对每个 commit 进行检查，使用 pylint 进行兼容性检查，配置如下：
# .pre-commit-config.yaml - repo: https://github.com/xiachufang/mirrors-pylint rev: v1.9.2 hooks: - id: pylint args: - --py3k - --score=n 迁移中 迁移办法一般是先排查关键字，如 iteritems/itervalues/xrange 等，这些可以全部使用 six 相应方法直接替换。 除此之外，应该给单元测试增加 Python3 环境，这样首先保证单元测试能在 Python3 下跑通，在调通单元测试之后，如果测试覆盖率高，那么基本已经改完很大一部分代码了。在给代码做适配是，可以使用 futurize 来自动修改一些代码，减少一些重复工作。并且可以参考 futurize 的 Cheat Sheet: Writing Python 2-3 compatible code 来做对照，进行修改代码。</description>
      <content>&lt;h2 id=&#34;前期规划&#34;&gt;前期规划&lt;/h2&gt;
&lt;p&gt;在开始迁移前，需要大致盘点一下都会有哪些工作量，哪些代码需要做兼容，哪些服务需要做迁移。前期可以大概分成一下几部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;主项目（主要的项目，承担了主要的日常开发任务以及业务需求）&lt;/li&gt;
&lt;li&gt;其他服务（为主项目服务的各个服务，如支付、IM、广告等）&lt;/li&gt;
&lt;li&gt;依赖库，依赖又包括：
&lt;ul&gt;
&lt;li&gt;公司内部基础组件&lt;/li&gt;
&lt;li&gt;第三方依赖&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在列出所有的 &amp;ldquo;代码清单&amp;rdquo; 后，需要有个先后顺序，来逐步的进行迁移。首先上面提到的三个大点中，&lt;strong&gt;其他服务&lt;/strong&gt; 其实优先级并不高，因为日常不怎么会开发，处于维护状态。因此保持正常运行即可，优先进行其他两项的迁移。而依赖库处处在引用，不提前进行 Python3 适配其他工作将无法进行。因此适配顺序如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;排查第三方依赖库，测试，升级到兼容 Python2/Python3 的版本&lt;/li&gt;
&lt;li&gt;排查公司内部基础组件库，测试，兼容适配 Python2/Python3&lt;/li&gt;
&lt;li&gt;进行主项目的代码层面适配，使用工具和一些库进行 2 和 3 的适配，使现有代码能同时在 2 和 3 下面跑。增加 py3 环境的单元测试。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在一切开始之前，还需要保证日常新加的代码不再引入不兼容的代码，因此应该提前使用 &lt;a href=&#34;https://pre-commit.com/&#34;&gt;pre-commit&lt;/a&gt; 对每个 commit 进行检查，使用 &lt;a href=&#34;https://github.com/pycqa/pylint&#34;&gt;pylint&lt;/a&gt; 进行兼容性检查，配置如下：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-shell&#34; data-lang=&#34;shell&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# .pre-commit-config.yaml&lt;/span&gt;

-   repo: https://github.com/xiachufang/mirrors-pylint
    rev: v1.9.2
    hooks:
    -   id: pylint
        args:
          - --py3k
          - --score&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;n
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;迁移中&#34;&gt;迁移中&lt;/h2&gt;
&lt;p&gt;迁移办法一般是先排查关键字，如 &lt;code&gt;iteritems&lt;/code&gt;/&lt;code&gt;itervalues&lt;/code&gt;/&lt;code&gt;xrange&lt;/code&gt; 等，这些可以全部使用 &lt;a href=&#34;https://six.readthedocs.io/&#34;&gt;six&lt;/a&gt; 相应方法直接替换。 除此之外，应该给单元测试增加 Python3 环境，这样首先保证单元测试能在 Python3 下跑通，在调通单元测试之后，如果测试覆盖率高，那么基本已经改完很大一部分代码了。在给代码做适配是，可以使用 &lt;a href=&#34;http://python-future.org/index.html&#34;&gt;futurize&lt;/a&gt; 来自动修改一些代码，减少一些重复工作。并且可以参考 futurize 的 &lt;a href=&#34;http://python-future.org/compatible_idioms.html&#34;&gt;Cheat Sheet: Writing Python 2-3 compatible code&lt;/a&gt; 来做对照，进行修改代码。&lt;/p&gt;
&lt;h3 id=&#34;会遇到的问题&#34;&gt;会遇到的问题&lt;/h3&gt;
&lt;h4 id=&#34;关键字方法&#34;&gt;关键字/方法&lt;/h4&gt;
&lt;p&gt;上面有提到，某些关键字或者方法，到了 Python3 里面已经没有了，比如 &lt;code&gt;xrange&lt;/code&gt;/&lt;code&gt;dict.iteritems&lt;/code&gt;/&lt;code&gt;dict.itervalues&lt;/code&gt;，这个一般全局搜索就能排除掉。&lt;/p&gt;
&lt;h4 id=&#34;内置函数返回类型&#34;&gt;内置函数返回类型&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;在 Python2 中，&lt;code&gt;dict.keys&lt;/code&gt; 返回的是一个 list，而到了 Python3 中，返回的是一个 &lt;code&gt;dict_keys&lt;/code&gt;，如果存在使用下标取，那么是会有问题的。如 &lt;code&gt;{&amp;quot;K&amp;quot;: &amp;quot;V&amp;quot;}.keys()[0]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Python2 中，map/reduce/filter 之类的关键字返回的是个 list，到了 3 中，返回的是 generator，如果需要下标访问是需要转成 list/tuple 的&lt;/li&gt;
&lt;li&gt;etc&amp;hellip;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;strbytesunicode&#34;&gt;str/bytes/unicode&lt;/h3&gt;
&lt;p&gt;这个应当属迁移的最繁琐的地方。&lt;/p&gt;
&lt;p&gt;中间遇到一次问题，排查了很久。代码库中有一个 &lt;code&gt;@cache&lt;/code&gt; 装饰器，用来缓存函数返回值，在 py2 中有如下一段代码:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;@cache&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;cache_key&amp;#39;&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;():
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;py2 返回结构&amp;#34;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;cache 拿到函数返回值后，原样放进 Memcached，因为 Python2 中，str/bytes 实际上是不敏感的，甚至可以等同。该 &lt;code&gt;foo&lt;/code&gt; 函数在 py2 下返回的是一个带 encoding 的 str，可以看做是 bytes 类型，这时候，如果在 py3 下把缓存结果取出来，那么将会是拿到一个 bytes 类型: &lt;code&gt;b&amp;quot;py2 返回结构&amp;quot;&lt;/code&gt;，这里就很容易出错了，在 Python2 下时，这个和 str 一样，可以当做 str 处理，但是 Python3 必须正视类型，该用 str(text type) 就不能用 bytes。&lt;/p&gt;
&lt;h2 id=&#34;代码库迁移完成&#34;&gt;代码库迁移完成&lt;/h2&gt;
&lt;p&gt;把代码库全部兼容 Python2 和 Python3 之后，这时候代码库是可以同时在 Python2 和 Python3 上跑的，因此可以逐步开始切分流量，大概可以分成这么几个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;把 staging 流量复制到 Python3 的环境&lt;/li&gt;
&lt;li&gt;部署 production 的 Python3 环境，并切分办公室流量至 Python3 环境&lt;/li&gt;
&lt;li&gt;切分线上小部分流量到 Python3 环境，并逐步增加，直至全部覆盖&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;迁移后工作&#34;&gt;迁移后工作&lt;/h2&gt;
&lt;p&gt;全部迁移完成后，自然会给代码加上 type hint，前期可以使用 pre-commit 增加 mypy 类型检查，并且只检查改动到的文件。与此同时，使用 &lt;a href=&#34;https://github.com/Instagram/MonkeyType&#34;&gt;MonkeyType&lt;/a&gt; 收集类型，自动添加一部分，减少工作量。&lt;/p&gt;
&lt;p&gt;至此，迁移工作已经全部完成。&lt;/p&gt;
</content>
    </item>
    
    <item>
      <title>Python 面试题整理[实习]</title>
      <link>https://when.run/posts/python-interview/</link>
      <pubDate>Fri, 28 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://when.run/posts/python-interview/</guid>
      <description>下面的内容均为最近几周找 Python 实习遇见的各种面试题，记录备用。其中有 bat 之类大厂也有十几个人的初创公司～（斜体的为遇见两次以上的。）
 Python 语法   说说你平时 Python 都用哪些库
  == 和 is 区别。
 == 是比较两对象的值，is 是比较在内存中的地址(id)， is 相当于 id(objx) == id(objy)。    深拷贝和浅拷贝。
   # 浅拷贝操作只会拷贝被拷贝对象的第一层对象，对于更深层级的只不过是拷贝其引用，如下例中 `a[2]` # 和 `lst[2]` 这两个对象为第二层，实际上浅拷贝之后，这两个还是一个对象。深拷贝会完全的拷贝被拷 # 贝对象的所有层级对象，也就是一个真正意义上的拷贝。 &amp;gt;&amp;gt;&amp;gt; from copy import copy, deepcopy &amp;gt;&amp;gt;&amp;gt; lst = [1, 2, [3, 4]] &amp;gt;&amp;gt;&amp;gt; a, b = copy(lst), deepcopy(lst) &amp;gt;&amp;gt;&amp;gt; a, b ([1, 2, [3, 4]], [1, 2, [3, 4]]) &amp;gt;&amp;gt;&amp;gt; id(lst[2]), id(a[2]), id(b[2]) (139842737414224, 139842737414224, 139842737414584) &amp;gt;&amp;gt;&amp;gt; lst[0] = 10 &amp;gt;&amp;gt;&amp;gt; a [1, 2, [3, 4]] &amp;gt;&amp;gt;&amp;gt; b [1, 2, [3, 4]] &amp;gt;&amp;gt;&amp;gt; lst[2][0] = &amp;#39;test&amp;#39; &amp;gt;&amp;gt;&amp;gt; lst [10, 2, [&amp;#39;test&amp;#39;, 4]] &amp;gt;&amp;gt;&amp;gt; a [1, 2, [&amp;#39;test&amp;#39;, 4]] &amp;gt;&amp;gt;&amp;gt; b [1, 2, [3, 4]]   __init__ 和 __new__。</description>
      <content>&lt;blockquote&gt;
&lt;p&gt;下面的内容均为最近几周找 Python 实习遇见的各种面试题，记录备用。其中有 bat 之类大厂也有十几个人的初创公司～（斜体的为遇见两次以上的。）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h1 id=&#34;python-语法&#34;&gt;Python 语法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;说说你平时 Python 都用哪些库&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;==&lt;/code&gt; 和 &lt;code&gt;is&lt;/code&gt; 区别。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;==&lt;/code&gt; 是比较两对象的值，&lt;code&gt;is&lt;/code&gt; 是比较在内存中的地址(id)， &lt;code&gt;is&lt;/code&gt; 相当于 &lt;code&gt;id(objx) == id(objy)&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;深拷贝和浅拷贝。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 浅拷贝操作只会拷贝被拷贝对象的第一层对象，对于更深层级的只不过是拷贝其引用，如下例中 `a[2]`&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# 和 `lst[2]` 这两个对象为第二层，实际上浅拷贝之后，这两个还是一个对象。深拷贝会完全的拷贝被拷&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# 贝对象的所有层级对象，也就是一个真正意义上的拷贝。&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; copy &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; copy, deepcopy
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; lst &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]]
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; a, b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; copy(lst), deepcopy(lst)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; a, b
([&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]], [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]])
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; id(lst[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]), id(a[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]), id(b[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;])
(&lt;span style=&#34;color:#ae81ff&#34;&gt;139842737414224&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;139842737414224&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;139842737414584&lt;/span&gt;)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; lst[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; a
[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]]
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; b
[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]]
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; lst[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;][&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; lst
[&lt;span style=&#34;color:#ae81ff&#34;&gt;10&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]]
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; a
[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;test&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]]
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; b
[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, [&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;]]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;__init__&lt;/code&gt; 和 &lt;code&gt;__new__&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;__init__&lt;/code&gt; 只是单纯的对实例进行某些属性的初始化，以及执行一些需要在新建对象时的必要自定义操作，无返回值。而 &lt;code&gt;__new__&lt;/code&gt; 返回的是用户创建的实例，这个才是真正用来创建实例的，所以 &lt;code&gt;__new__&lt;/code&gt; 是在 &lt;code&gt;__init__&lt;/code&gt; 之前执行的，先创建再初始化。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Python 2 和 Python 3 有哪些区别？&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html&#34;&gt;http://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;连接字符串都有哪些方式？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;格式化字符连接（&lt;code&gt;%s&lt;/code&gt;)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;format&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;join&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;+&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;fstring&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何判断某个对象是什么类型？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;type(obj)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;isinstance(obj, x)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;生成器是什么？&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;一言难尽，推荐看这个 &lt;a href=&#34;https://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html&#34;&gt;stackoverflow 答案的翻译&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python 中的 GIL 是什么？全称？举个例子说说其具体体现。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;GIL 全称 Global Interpreter Lock（全局解释器锁），任何 Python 线程执行前，必须先获得 GIL 锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。要避免这种“现象”利用操作系统的多核优势可以有下面几种方法：
&lt;ul&gt;
&lt;li&gt;使用 C 语言编写扩展，创建原生线程，摆脱 GIL，但是即使是扩展，在 Python 代码内，任意一条Python 代码还是会有 GIL 限制&lt;/li&gt;
&lt;li&gt;使用多进程代替多线程，使用多进程时，每个进程都有自己的 GIL。故不存在进程与进程之间的 GIL 限制。但是多进程不能共享内存。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;s = &#39;abcd&#39;, s[2] = &#39;e&#39;&lt;/code&gt; 运行结果是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;报错，字符串是不可变对象&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Python 中，&lt;code&gt;sorted&lt;/code&gt; 函数内部是什么算法？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在 &lt;a href=&#34;https://docs.python.org/3/howto/sorting.html?highlight=Timsort&#34;&gt;官方文档&lt;/a&gt; 里面有提到，用的是 &lt;a href=&#34;https://en.wikipedia.org/wiki/Timsort&#34;&gt;Timsort&lt;/a&gt; 算法&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码是一个什么样的过程？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;编码是二进制到字符的过程&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Python 里面怎么实现协程？&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://mp.weixin.qq.com/s/TKrb0i5fF0pJdRIgGC9qQQ&#34;&gt;说清道明：协程是什么&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;requests&lt;/code&gt; 包新建一个 &lt;code&gt;session&lt;/code&gt; 再 &lt;code&gt;get&lt;/code&gt; 和普通的 &lt;code&gt;requests.get&lt;/code&gt; 有什么区别？（tcp长连接）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;维持一个会话，** 建立一个tcp长连接** ，cookie 自动保存，下次请求还是一个会话。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Python 都有哪些数据结构？可变对象，不可变对象分别有哪些？&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可变对象：列表，字典&lt;/li&gt;
&lt;li&gt;不可变对象：字符串，数字，元组，集合&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;在 Python 内，函数传参是引用传递还是值传递？&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;引用传递。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你会对你的项目写测试么？用哪些方法哪些库？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;doctest&lt;/li&gt;
&lt;li&gt;pytest&lt;/li&gt;
&lt;li&gt;unitest&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;请新建一个只有一个元素 &lt;code&gt;1&lt;/code&gt; 的列表和元组。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;lst = [1]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;tup = (1,)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;函数默认参数是可变对象情况。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;foo&lt;/span&gt;(a, b&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]):
        &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(b)
        b&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(a)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(b)
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; foo(val)
&lt;span style=&#34;color:#75715e&#34;&gt;# [1, 2]&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# [1, 2, 4]&lt;/span&gt;
&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; foo(val)
&lt;span style=&#34;color:#75715e&#34;&gt;# [1, 2, 4]&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# [1, 2, 4, 4]&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# 这里可以看到，第二次执行函数时，默认参数 b 的值已经变成 `[1, 2, 4]` 了，原因是，默认参数只在第&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# 一次执行时会进行初始化，后面就默认使用 **初始化后的这个对象(引用)**，但是这里 b 是可变对象，&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;#添加了一个元素还是之前的对象，所以，引用没变，不过是值变了而已。&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;Flask 的 Route 是怎么实现的？&lt;/em&gt; 你认为 Flask 框架有什么优缺点？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;实际上在 Flask 类里面，&lt;code&gt;route&lt;/code&gt; 可以简单理解为不过是把对应的路由规则作为键，装饰的视图函数作为值，存到 &lt;code&gt;werkzeug.routing.Map&lt;/code&gt; 对象（可以看成是和字典类似的数据结构）里。这里是 &lt;a href=&#34;https://github.com/pallets/flask/blob/master/flask/app.py#L1076-L1120&#34;&gt;源码&lt;/a&gt;，好理解些。这是之前写的一篇 &lt;a href=&#34;https://github.com/x1ah/Blog/issues/4&#34;&gt;笔记&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Flask 优点是轻量，灵活，可高度定制，插件化。缺点也是过于轻量，功能必须通过第三方插件实现，插件质量参差不齐，也不能完全保证后期维护。&lt;/li&gt;
&lt;li&gt;这几点都只是个人之见，更详细标准的还需自行寻找答案。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;WSGI 是什么？uWSGI， nginx 这些都是什么用途？&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这里有&lt;a href=&#34;https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3&#34;&gt;维基百科&lt;/a&gt; 的解释，WSGI 就是一个通用的标准，遵守这个标准，我们能让我们的 Web 框架更加通用，编写更加简单。&lt;/li&gt;
&lt;li&gt;uwsgi 和 Nginx 都是 Web Server，不同的是 Nginx 负责 外网请求 &amp;mdash;(转换)&amp;ndash;&amp;gt; 内网请求，uwsgi 负责的是 内网请求 -&amp;gt; Python Web 程序。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;nginx 和 Apache 的区别？(参考 &lt;a href=&#34;https://github.com/taizilongxu/interview_python#7-apache%E5%92%8Cnginx%E7%9A%84%E5%8C%BA%E5%88%AB&#34;&gt;interview_python&lt;/a&gt;)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;nginx 相对 apache 的优点：
&lt;ul&gt;
&lt;li&gt;轻量级，同样起web 服务，比apache 占用更少的内存及资源&lt;/li&gt;
&lt;li&gt;抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能&lt;/li&gt;
&lt;li&gt;配置简洁&lt;/li&gt;
&lt;li&gt;高度模块化的设计，编写模块相对简单&lt;/li&gt;
&lt;li&gt;社区活跃&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;apache 相对nginx 的优点：
&lt;ul&gt;
&lt;li&gt;rewrite ，比nginx 的rewrite 强大&lt;/li&gt;
&lt;li&gt;模块超多，基本想到的都可以找到&lt;/li&gt;
&lt;li&gt;少bug ，nginx 的bug 相对较多&lt;/li&gt;
&lt;li&gt;超稳定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你部署 Python 项目时用的是 uWSGI 的哪个模式？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;默认模式&lt;/li&gt;
&lt;li&gt;这个应该问的可能性极小了，可翻阅 &lt;a href=&#34;http://uwsgi-docs-cn.readthedocs.io/zh_CN/latest/WSGIquickstart.html&#34;&gt;uwsgi 文档&lt;/a&gt; 查找更详细的资料&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;数据结构算法&#34;&gt;数据结构，算法&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;层次遍历二叉树用什么方法？&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# coding: utf-8&lt;/span&gt;

&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; collections &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; deque


&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;BNode&lt;/span&gt;:
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34; 二叉树节点 &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, value, left&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;None, right&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;None):
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;value &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; value
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; left
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; right


&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;level_traverse&lt;/span&gt;(binary_tree):
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34; 层次遍历二叉树 &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;
    stack &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; deque([binary_tree])
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; stack:
        top &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;popleft()
        &lt;span style=&#34;color:#66d9ef&#34;&gt;print&lt;/span&gt;(top&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;value)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; top&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left:
            stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(top&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;left)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; top&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right:
            stack&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(top&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;right)


&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; __name__ &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;__main__&amp;#34;&lt;/span&gt;:
    b_tree &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; BNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, BNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, BNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, BNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;, BNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;)))), BNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, BNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;6&lt;/span&gt;, right&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;BNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;))))
    level_traverse(b_tree)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;非平衡二叉数如何变成平衡二叉数？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;https://segmentfault.com/a/1190000006123188&#34;&gt;AVL平衡二叉树详解与实现&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;先，中，后序遍历二叉数。完全二叉数是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;完全二叉树：深度为k有n个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度k的满二叉树，序号为1到n的节点一对一对应时，称为“完全二叉树”。（摘自维基百科）&lt;/li&gt;
&lt;li&gt;先序：先根后左再右&lt;/li&gt;
&lt;li&gt;中序：先左后中再右&lt;/li&gt;
&lt;li&gt;后序：先左后右再根&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如何判断两个单链表是否相交于某个节点，包括 X 型，Y 型，V 型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;X 型不可能存在，一个单链表节点不存在两个不同的后继。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 存在 V 型和 Y 型，如果交叉，则最后一个节点肯定是相同的，故直接从最后一个节点进行反向遍历。&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# 反转单链表&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reverse_single_link_lst&lt;/span&gt;(link_lst):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;not&lt;/span&gt; link_lst:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; link_lst
    pre &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; link_lst
    cur &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; link_lst&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
    pre&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; None
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; cur:
        tmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
        cur&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; pre
        pre &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cur
        cur &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; tmp
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; pre

&lt;span style=&#34;color:#75715e&#34;&gt;# 寻找交叉点&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;point&lt;/span&gt;(node_a, node_b):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; node_a &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; None &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; node_b &lt;span style=&#34;color:#f92672&#34;&gt;is&lt;/span&gt; None:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; None
    next_a, next_b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; node_a, node_b
    &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; next_a &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; next_b:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; next_a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; next_b&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; next_a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; next_b&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; (next_a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; next_b&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val):
                next_a, next_b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next_a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next, next_b&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
                &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; next_a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val
        next_a, next_b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next_a&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next, next_b&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; None

&lt;span style=&#34;color:#75715e&#34;&gt;# 构造单链表&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;class&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Node&lt;/span&gt;(object):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; __init__(self, value, next&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;None):
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;val &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; value
        self&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;next &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; next

a &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ListNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, ListNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, ListNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;, ListNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, ListNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;)))))
b &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ListNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;7&lt;/span&gt;, ListNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;9&lt;/span&gt;, ListNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;4&lt;/span&gt;, ListNode(&lt;span style=&#34;color:#ae81ff&#34;&gt;5&lt;/span&gt;))))

ra &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; reverse_single_link_lst(a)
rb &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; reverse_single_link_lst(b)
point(ra, rb)
&lt;span style=&#34;color:#75715e&#34;&gt;# output:&lt;/span&gt;
&lt;span style=&#34;color:#75715e&#34;&gt;# 4&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如何判断两个单链表是否是同一个链表。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;直接判断第一个节点即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;单链表逆转。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;见上面判断交叉链表内的 &lt;code&gt;reverse_single_link_lst()&lt;/code&gt; 函数。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;堆，栈，队列。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)&#34;&gt;堆&lt;/a&gt;， &lt;a href=&#34;https://zh.wikipedia.org/zh-hans/%E5%A0%86%E6%A0%88&#34;&gt;栈&lt;/a&gt;， &lt;a href=&#34;https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97&#34;&gt;队列&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;说说你知道的排序算法以及其时间复杂度。&lt;/em&gt;
&lt;img src=&#34;http://ww1.sinaimg.cn/large/005NaGmtly1fenoomcn03j30iz07874f.jpg&#34; alt=&#34;&#34;&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;手写快速排序。画画堆排序的原理及过程。&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 快速排序，lz 当时写的比较复杂，但是是最常见的写法（紧张导致有几个小bug），如下&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;quick_sort&lt;/span&gt;(lst, start, stop):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; start &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; stop:
        i, j, x &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; start, stop, lst[start]
        &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; j:
            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; j) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; (lst[j] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; x):
                j &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; j):
                lst[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lst[j]
                i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; j) &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; (lst[i] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; x):
                i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; j):
                lst[j] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; lst[i]
                j &lt;span style=&#34;color:#f92672&#34;&gt;-=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
        lst[i] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; x
        quick_sort(lst, start, i&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;)
        quick_sort(lst, i&lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, stop)
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; lst
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;之后面试官 &lt;a href=&#34;https://github.com/akun&#34;&gt;akun&lt;/a&gt; 大哥给了个特别简洁的写法，三路复用，地址在 &lt;a href=&#34;https://gist.github.com/akun/d90998068f4e1f3eb169&#34;&gt;Gist&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;qsort&lt;/span&gt;(alist):
    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&amp;#34;&amp;#34;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    quick sort(easy way, but more memory)
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    test: python -m doctest qsort.py
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;gt;&amp;gt;&amp;gt; import math
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;gt;&amp;gt;&amp;gt; import random
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;gt;&amp;gt;&amp;gt; size = 100
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;gt;&amp;gt;&amp;gt; alist = [random.randint(0, size * 10) for i in range(size)]
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;gt;&amp;gt;&amp;gt; qlist = qsort(alist)
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;gt;&amp;gt;&amp;gt; alist.sort()
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;gt;&amp;gt;&amp;gt; assert qlist == alist
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;#34;&amp;#34;&amp;#34;&lt;/span&gt;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; len(alist) &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; alist

    key &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; alist[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]
    left_list, middle_list, right_list &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [], [], []

    [{i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; key: left_list, i &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; key: middle_list, i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; key: right_list}[
        True
    ]&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;append(i) &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;in&lt;/span&gt; alist]

    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; qsort(left_list) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; middle_list &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; qsort(right_list)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;说说你所了解的加密算法，编码算法，以及压缩算法。了解 base64 的原理么？
&lt;ul&gt;
&lt;li&gt;只说了听过 base64, md5 这几种编码。。。。。自行搜索吧，考的概率极小。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;数据库&#34;&gt;数据库&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;索引是什么原理？有什么优缺点？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;参考 &lt;a href=&#34;http://blog.csdn.net/kennyrose/article/details/7532032&#34;&gt;数据库索引的实现原理&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;乐观锁和悲观锁是什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.hollischuang.com/archives/934&#34;&gt;深入理解乐观锁与悲观锁&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你为什么选择 Redis 而不是 MongoDB 或者其他的？（有个项目用了 Redis）&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://segmentfault.com/q/1010000002588088/a-1020000002589415&#34;&gt;redis、memcache、mongoDB有哪些区别？&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;SQL 和 NoSQL 区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.jianshu.com/p/b32fe4fe45a3&#34;&gt;SQL 和 NoSQL 的区别&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;网络&#34;&gt;网络&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;从浏览器输入网址到网页渲染完毕这过程发生了什么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/skyline75489/what-happens-when-zh_CN&#34;&gt;这里&lt;/a&gt; 说的非常详细，看面的岗位不同，回答的侧重点不一样。如面的 Web ，可以侧重说说 nginx -&amp;gt; uwsgi -&amp;gt; Python -&amp;gt; uwsgi -&amp;gt; nginx 这个过程，（WSGI 标准）&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;TCP 三次握手四次挥手详细说下。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://blog.csdn.net/whuslei/article/details/6667471&#34;&gt;TCP协议中的三次握手和四次挥手(图解)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为什么是三次握手？两次不行么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.cnblogs.com/techzi/archive/2011/10/18/2216751.html&#34;&gt;TCP连接建立过程中为什么需要“三次握手”&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;说说 TCP 和 UDP 的区别。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;TCP（传输层）
&lt;ul&gt;
&lt;li&gt;优点：TCP 面向连接，可靠，稳定，传输数据前需要建立连接，故有三次握手四次挥手，还有拥塞控制，重传等&lt;/li&gt;
&lt;li&gt;缺点：慢，占用系统资源，有确认机制，三次握手，所以容易被攻击，DDos&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;UDP
&lt;ul&gt;
&lt;li&gt;优点：快，无状态传输协议&lt;/li&gt;
&lt;li&gt;缺点：不稳定，不可靠，容易丢包&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;谈谈你对 SQL 注入、 XSS 、 CSRF 的理解。以及如何防范。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://cnodejs.org/topic/50463565329c5139760c34a1&#34;&gt;关于XSS（跨站脚本攻击）和CSRF（跨站请求伪造)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.m.wikipedia.org/zh-hans/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A&#34;&gt;SQL 注入&lt;/a&gt;，现在多数采用 ORM，以及参数化查询，很少再出现。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;说说 DNS 是什么东西。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据域名寻找 主机 IP 的协议。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 是工作在七层模型的哪一层？DNS 又是哪一层？TCP 和 IP 呢？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTP，DNS 应用层，TCP 传输层，IP 网络层。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;说说你知道的 HTTP 方法和 状态码。&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81&#34;&gt;状态码&lt;/a&gt;，这里只需要大概说说，以 1××，2××，3×× 这样的层面说，没有必要细到每一个状态码。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#.E8.AF.B7.E6.B1.82.E6.96.B9.E6.B3.95&#34;&gt;HTTP 请求方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;HTTP 的 GET 和 POST 有什么区别？&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;本质上，GET 和 POST 只不过是 &lt;strong&gt;发送机制不同&lt;/strong&gt; 。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;HTTP 和 HTTPS 的区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;HTTPS = HTTP + SSL&lt;/li&gt;
&lt;li&gt;HTTP 默认使用 80 端口，HTTPS 使用 443 端口。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE#.E4.B8.8EHTTP.E7.9A.84.E5.B7.AE.E5.BC.82&#34;&gt;更详细&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;说说你知道的 HTTP 包头部信息里都有哪些字段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这个随便抓下包就知道了，就不说了～&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;em&gt;HTTP 包头部信息里面的 &lt;code&gt;Host&lt;/code&gt; 字段是什么作用？&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;表示当前请求服务器的主机名&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;说说 cookie 里面你都知道哪些字段。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://javascript.ruanyifeng.com/bom/cookie.html&#34;&gt;Cookie&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Session 是什么东西？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://harttle.com/2015/08/10/cookie-session.html&#34;&gt;Cookie/Session的机制与安全&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;在写爬虫过程中，如果遇见需要加载 js 的情况你是如何处理的。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Selenium，PhantomJS&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;普通匿名代理和高匿代理有什么区别？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来自普通匿名代理的请求在服务端能看见真实 IP， 而高匿代理在服务端看不见真实 IP，只能看见代理服务器 IP。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;你知道哪些反爬措施？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;加代理，加头部，爬取速度控制，随机 UA，模拟真实用户的点击习惯去请求。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;操作系统&#34;&gt;操作系统&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;进程和线程以及协程的区别？&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;多线程和多进程的区别？&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;信号量和互斥量的区别？&lt;/li&gt;
&lt;li&gt;堆内存是干嘛的？&lt;/li&gt;
&lt;li&gt;如何检验当前机器是大端模式还是小端模式？&lt;/li&gt;
&lt;li&gt;如何让某个程序在后台运行？（Linux）&lt;/li&gt;
&lt;li&gt;sed, awk 用法（Linux）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;编程题&#34;&gt;编程题&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;手写二分查找，&lt;em&gt;快速排序&lt;/em&gt;。&lt;/li&gt;
&lt;li&gt;~还有一个 SQL 语句的，一条 SQL 语句打印某张表某个 group count  TOP 5。~&lt;/li&gt;
&lt;li&gt;Python 中正则模块 &lt;code&gt;re&lt;/code&gt; 里 &lt;code&gt;match&lt;/code&gt; 函数 和 &lt;code&gt;search&lt;/code&gt; 函数有什么区别？举例说明。&lt;/li&gt;
&lt;li&gt;一条语句求 0 - 999999 内能被 7 整除的所有数的和。&lt;/li&gt;
&lt;li&gt;实现一个链表结构，要求其插入第一个节点，删除最后一个节点的复杂度为 O(1)。&lt;/li&gt;
&lt;li&gt;实现一个 &lt;code&gt;retry&lt;/code&gt; 装饰器，使用如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 可以指定重试次数，直到函数返回正确结果。&lt;/span&gt;
&lt;span style=&#34;color:#a6e22e&#34;&gt;@retry&lt;/span&gt;(retries&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;)
&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;func&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;args, &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kw):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;try&lt;/span&gt;:
        &lt;span style=&#34;color:#75715e&#34;&gt;# some action&lt;/span&gt;
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; True
    &lt;span style=&#34;color:#66d9ef&#34;&gt;except&lt;/span&gt;:
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; False
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;大概可以像下面这样写，&lt;/p&gt;
&lt;hr&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-python&#34; data-lang=&#34;python&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;from&lt;/span&gt; functools &lt;span style=&#34;color:#f92672&#34;&gt;import&lt;/span&gt; wraps

&lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;retry&lt;/span&gt;(retries&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;):
    &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;timesf&lt;/span&gt;(func):
        &lt;span style=&#34;color:#a6e22e&#34;&gt;@wraps&lt;/span&gt;(func)
        &lt;span style=&#34;color:#66d9ef&#34;&gt;def&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wrap&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;args, &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kw):
            i &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;
            status &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; True
            &lt;span style=&#34;color:#66d9ef&#34;&gt;while&lt;/span&gt; status &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; i &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; times:
                status &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; func(&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;args, &lt;span style=&#34;color:#f92672&#34;&gt;**&lt;/span&gt;kw)
                i &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; status
        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; wrap
    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; timesf
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;有一个4G 的文本文件，存储的是酒店信息，每行存的是一个酒店ID，可以重复。请编写程序输出一个新文件，新文件内容为每行一条数据，每行的数据格式如下：&lt;code&gt;酒店ID + 出现次数&lt;/code&gt;（最后提到了其他想法，如文件切片，bitmap 之类）&lt;/li&gt;
&lt;li&gt;实现一个函数，根据字典序比较两字符串大小，不允许用库函数，尽量越底层实现越好。（手写）&lt;/li&gt;
&lt;li&gt;实现一个函数，检验一个字符串是否符合 &lt;code&gt;xxxx-xx-xx&lt;/code&gt; 这样的日期格式，注意润年，大小月，不允许用库函数，尽量越底层实现越好。（手写）&lt;/li&gt;
&lt;li&gt;我们是做地图相关工作的，现在给你提供一个三维的数据，数据描述的是不同时间一些地图上的一些地点坐标，分别有时间，x轴坐标，y轴坐标，请你设计一个算法，能够得到一天内地图上的 TOP 10 热点地区，地区大小也相应的自己作合适调整，开放性题目。&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id=&#34;概率论&#34;&gt;概率论&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;一副扑克除去大小王，共 52 张排，随机取三张扑克，求同花（三张扑克同一种花色）和顺子的概率。&lt;/li&gt;
&lt;li&gt;其他忘了 Orz&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;原文：https://github.com/x1ah/Blog/issues/9&lt;/p&gt;
&lt;/blockquote&gt;
</content>
    </item>
    
  </channel>
</rss>
