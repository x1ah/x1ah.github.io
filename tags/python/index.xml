<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Python on x1ah</title><link>https://when.run/tags/python/</link><description>Recent content in Python on x1ah</description><generator>Hugo -- gohugo.io</generator><language>zh</language><lastBuildDate>Tue, 12 Nov 2019 00:00:00 +0000</lastBuildDate><atom:link href="https://when.run/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python2 迁移到 Python3 规划和实施</title><link>https://when.run/posts/python2-to-python3/</link><pubDate>Tue, 12 Nov 2019 00:00:00 +0000</pubDate><guid>https://when.run/posts/python2-to-python3/</guid><description>前期规划 在开始迁移前，需要大致盘点一下都会有哪些工作量，哪些代码需要做兼容，哪些服务需要做迁移。前期可以大概分成一下几部分：
主项目（主要的项目，承担了主要的日常开发任务以及业务需求） 其他服务（为主项目服务的各个服务，如支付、IM、广告等） 依赖库，依赖又包括： 公司内部基础组件 第三方依赖 在列出所有的 &amp;ldquo;代码清单&amp;rdquo; 后，需要有个先后顺序，来逐步的进行迁移。首先上面提到的三个大点中，其他服务 其实优先级并不高，因为日常不怎么会开发，处于维护状态。因此保持正常运行即可，优先进行其他两项的迁移。而依赖库处处在引用，不提前进行 Python3 适配其他工作将无法进行。因此适配顺序如下：
排查第三方依赖库，测试，升级到兼容 Python2/Python3 的版本 排查公司内部基础组件库，测试，兼容适配 Python2/Python3 进行主项目的代码层面适配，使用工具和一些库进行 2 和 3 的适配，使现有代码能同时在 2 和 3 下面跑。增加 py3 环境的单元测试。 在一切开始之前，还需要保证日常新加的代码不再引入不兼容的代码，因此应该提前使用 pre-commit 对每个 commit 进行检查，使用 pylint 进行兼容性检查，配置如下：
# .pre-commit-config.yaml - repo: https://github.com/xiachufang/mirrors-pylint rev: v1.9.2 hooks: - id: pylint args: - --py3k - --score=n 迁移中 迁移办法一般是先排查关键字，如 iteritems/itervalues/xrange 等，这些可以全部使用 six 相应方法直接替换。 除此之外，应该给单元测试增加 Python3 环境，这样首先保证单元测试能在 Python3 下跑通，在调通单元测试之后，如果测试覆盖率高，那么基本已经改完很大一部分代码了。在给代码做适配是，可以使用 futurize 来自动修改一些代码，减少一些重复工作。并且可以参考 futurize 的 Cheat Sheet: Writing Python 2-3 compatible code 来做对照，进行修改代码。</description><content>&lt;h2 id="前期规划">前期规划&lt;/h2>
&lt;p>在开始迁移前，需要大致盘点一下都会有哪些工作量，哪些代码需要做兼容，哪些服务需要做迁移。前期可以大概分成一下几部分：&lt;/p>
&lt;ul>
&lt;li>主项目（主要的项目，承担了主要的日常开发任务以及业务需求）&lt;/li>
&lt;li>其他服务（为主项目服务的各个服务，如支付、IM、广告等）&lt;/li>
&lt;li>依赖库，依赖又包括：
&lt;ul>
&lt;li>公司内部基础组件&lt;/li>
&lt;li>第三方依赖&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;p>在列出所有的 &amp;ldquo;代码清单&amp;rdquo; 后，需要有个先后顺序，来逐步的进行迁移。首先上面提到的三个大点中，&lt;strong>其他服务&lt;/strong> 其实优先级并不高，因为日常不怎么会开发，处于维护状态。因此保持正常运行即可，优先进行其他两项的迁移。而依赖库处处在引用，不提前进行 Python3 适配其他工作将无法进行。因此适配顺序如下：&lt;/p>
&lt;ol>
&lt;li>排查第三方依赖库，测试，升级到兼容 Python2/Python3 的版本&lt;/li>
&lt;li>排查公司内部基础组件库，测试，兼容适配 Python2/Python3&lt;/li>
&lt;li>进行主项目的代码层面适配，使用工具和一些库进行 2 和 3 的适配，使现有代码能同时在 2 和 3 下面跑。增加 py3 环境的单元测试。&lt;/li>
&lt;/ol>
&lt;p>在一切开始之前，还需要保证日常新加的代码不再引入不兼容的代码，因此应该提前使用 &lt;a href="https://pre-commit.com/">pre-commit&lt;/a> 对每个 commit 进行检查，使用 &lt;a href="https://github.com/pycqa/pylint">pylint&lt;/a> 进行兼容性检查，配置如下：&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-shell" data-lang="shell">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># .pre-commit-config.yaml&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>- repo: https://github.com/xiachufang/mirrors-pylint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> rev: v1.9.2
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> hooks:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - id: pylint
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> args:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --py3k
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> - --score&lt;span style="color:#f92672">=&lt;/span>n
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="迁移中">迁移中&lt;/h2>
&lt;p>迁移办法一般是先排查关键字，如 &lt;code>iteritems&lt;/code>/&lt;code>itervalues&lt;/code>/&lt;code>xrange&lt;/code> 等，这些可以全部使用 &lt;a href="https://six.readthedocs.io/">six&lt;/a> 相应方法直接替换。 除此之外，应该给单元测试增加 Python3 环境，这样首先保证单元测试能在 Python3 下跑通，在调通单元测试之后，如果测试覆盖率高，那么基本已经改完很大一部分代码了。在给代码做适配是，可以使用 &lt;a href="http://python-future.org/index.html">futurize&lt;/a> 来自动修改一些代码，减少一些重复工作。并且可以参考 futurize 的 &lt;a href="http://python-future.org/compatible_idioms.html">Cheat Sheet: Writing Python 2-3 compatible code&lt;/a> 来做对照，进行修改代码。&lt;/p>
&lt;h3 id="会遇到的问题">会遇到的问题&lt;/h3>
&lt;h4 id="关键字方法">关键字/方法&lt;/h4>
&lt;p>上面有提到，某些关键字或者方法，到了 Python3 里面已经没有了，比如 &lt;code>xrange&lt;/code>/&lt;code>dict.iteritems&lt;/code>/&lt;code>dict.itervalues&lt;/code>，这个一般全局搜索就能排除掉。&lt;/p>
&lt;h4 id="内置函数返回类型">内置函数返回类型&lt;/h4>
&lt;ul>
&lt;li>在 Python2 中，&lt;code>dict.keys&lt;/code> 返回的是一个 list，而到了 Python3 中，返回的是一个 &lt;code>dict_keys&lt;/code>，如果存在使用下标取，那么是会有问题的。如 &lt;code>{&amp;quot;K&amp;quot;: &amp;quot;V&amp;quot;}.keys()[0]&lt;/code>&lt;/li>
&lt;li>Python2 中，map/reduce/filter 之类的关键字返回的是个 list，到了 3 中，返回的是 generator，如果需要下标访问是需要转成 list/tuple 的&lt;/li>
&lt;li>etc&amp;hellip;&lt;/li>
&lt;/ul>
&lt;h3 id="strbytesunicode">str/bytes/unicode&lt;/h3>
&lt;p>这个应当属迁移的最繁琐的地方。&lt;/p>
&lt;p>中间遇到一次问题，排查了很久。代码库中有一个 &lt;code>@cache&lt;/code> 装饰器，用来缓存函数返回值，在 py2 中有如下一段代码:&lt;/p>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@cache&lt;/span>(&lt;span style="color:#e6db74">&amp;#39;cache_key&amp;#39;&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>():
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#e6db74">&amp;#34;py2 返回结构&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>cache 拿到函数返回值后，原样放进 Memcached，因为 Python2 中，str/bytes 实际上是不敏感的，甚至可以等同。该 &lt;code>foo&lt;/code> 函数在 py2 下返回的是一个带 encoding 的 str，可以看做是 bytes 类型，这时候，如果在 py3 下把缓存结果取出来，那么将会是拿到一个 bytes 类型: &lt;code>b&amp;quot;py2 返回结构&amp;quot;&lt;/code>，这里就很容易出错了，在 Python2 下时，这个和 str 一样，可以当做 str 处理，但是 Python3 必须正视类型，该用 str(text type) 就不能用 bytes。&lt;/p>
&lt;h2 id="代码库迁移完成">代码库迁移完成&lt;/h2>
&lt;p>把代码库全部兼容 Python2 和 Python3 之后，这时候代码库是可以同时在 Python2 和 Python3 上跑的，因此可以逐步开始切分流量，大概可以分成这么几个步骤：&lt;/p>
&lt;ol>
&lt;li>把 staging 流量复制到 Python3 的环境&lt;/li>
&lt;li>部署 production 的 Python3 环境，并切分办公室流量至 Python3 环境&lt;/li>
&lt;li>切分线上小部分流量到 Python3 环境，并逐步增加，直至全部覆盖&lt;/li>
&lt;/ol>
&lt;h2 id="迁移后工作">迁移后工作&lt;/h2>
&lt;p>全部迁移完成后，自然会给代码加上 type hint，前期可以使用 pre-commit 增加 mypy 类型检查，并且只检查改动到的文件。与此同时，使用 &lt;a href="https://github.com/Instagram/MonkeyType">MonkeyType&lt;/a> 收集类型，自动添加一部分，减少工作量。&lt;/p>
&lt;p>至此，迁移工作已经全部完成。&lt;/p></content></item><item><title>Python 面试题整理[实习]</title><link>https://when.run/posts/python-interview/</link><pubDate>Fri, 28 Apr 2017 00:00:00 +0000</pubDate><guid>https://when.run/posts/python-interview/</guid><description>下面的内容均为最近几周找 Python 实习遇见的各种面试题，记录备用。其中有 bat 之类大厂也有十几个人的初创公司～（斜体的为遇见两次以上的。）
Python 语法 说说你平时 Python 都用哪些库
== 和 is 区别。
== 是比较两对象的值，is 是比较在内存中的地址(id)， is 相当于 id(objx) == id(objy)。 深拷贝和浅拷贝。
# 浅拷贝操作只会拷贝被拷贝对象的第一层对象，对于更深层级的只不过是拷贝其引用，如下例中 `a[2]` # 和 `lst[2]` 这两个对象为第二层，实际上浅拷贝之后，这两个还是一个对象。深拷贝会完全的拷贝被拷 # 贝对象的所有层级对象，也就是一个真正意义上的拷贝。 &amp;gt;&amp;gt;&amp;gt; from copy import copy, deepcopy &amp;gt;&amp;gt;&amp;gt; lst = [1, 2, [3, 4]] &amp;gt;&amp;gt;&amp;gt; a, b = copy(lst), deepcopy(lst) &amp;gt;&amp;gt;&amp;gt; a, b ([1, 2, [3, 4]], [1, 2, [3, 4]]) &amp;gt;&amp;gt;&amp;gt; id(lst[2]), id(a[2]), id(b[2]) (139842737414224, 139842737414224, 139842737414584) &amp;gt;&amp;gt;&amp;gt; lst[0] = 10 &amp;gt;&amp;gt;&amp;gt; a [1, 2, [3, 4]] &amp;gt;&amp;gt;&amp;gt; b [1, 2, [3, 4]] &amp;gt;&amp;gt;&amp;gt; lst[2][0] = &amp;#39;test&amp;#39; &amp;gt;&amp;gt;&amp;gt; lst [10, 2, [&amp;#39;test&amp;#39;, 4]] &amp;gt;&amp;gt;&amp;gt; a [1, 2, [&amp;#39;test&amp;#39;, 4]] &amp;gt;&amp;gt;&amp;gt; b [1, 2, [3, 4]] __init__ 和 __new__。</description><content>&lt;blockquote>
&lt;p>下面的内容均为最近几周找 Python 实习遇见的各种面试题，记录备用。其中有 bat 之类大厂也有十几个人的初创公司～（斜体的为遇见两次以上的。）&lt;/p>
&lt;/blockquote>
&lt;h1 id="python-语法">Python 语法&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>&lt;em>说说你平时 Python 都用哪些库&lt;/em>&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;code>==&lt;/code> 和 &lt;code>is&lt;/code> 区别。&lt;/p>
&lt;ul>
&lt;li>&lt;code>==&lt;/code> 是比较两对象的值，&lt;code>is&lt;/code> 是比较在内存中的地址(id)， &lt;code>is&lt;/code> 相当于 &lt;code>id(objx) == id(objy)&lt;/code>。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>深拷贝和浅拷贝。&lt;/em>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 浅拷贝操作只会拷贝被拷贝对象的第一层对象，对于更深层级的只不过是拷贝其引用，如下例中 `a[2]`&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 和 `lst[2]` 这两个对象为第二层，实际上浅拷贝之后，这两个还是一个对象。深拷贝会完全的拷贝被拷&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 贝对象的所有层级对象，也就是一个真正意义上的拷贝。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#f92672">from&lt;/span> copy &lt;span style="color:#f92672">import&lt;/span> copy, deepcopy
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> lst &lt;span style="color:#f92672">=&lt;/span> [&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, [&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a, b &lt;span style="color:#f92672">=&lt;/span> copy(lst), deepcopy(lst)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a, b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>([&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, [&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>]], [&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, [&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>]])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> id(lst[&lt;span style="color:#ae81ff">2&lt;/span>]), id(a[&lt;span style="color:#ae81ff">2&lt;/span>]), id(b[&lt;span style="color:#ae81ff">2&lt;/span>])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>(&lt;span style="color:#ae81ff">139842737414224&lt;/span>, &lt;span style="color:#ae81ff">139842737414224&lt;/span>, &lt;span style="color:#ae81ff">139842737414584&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> lst[&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">10&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, [&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, [&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> lst[&lt;span style="color:#ae81ff">2&lt;/span>][&lt;span style="color:#ae81ff">0&lt;/span>] &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#e6db74">&amp;#39;test&amp;#39;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> lst
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">10&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, [&lt;span style="color:#e6db74">&amp;#39;test&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> a
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, [&lt;span style="color:#e6db74">&amp;#39;test&amp;#39;&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>]]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>, [&lt;span style="color:#ae81ff">3&lt;/span>, &lt;span style="color:#ae81ff">4&lt;/span>]]
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;code>__init__&lt;/code> 和 &lt;code>__new__&lt;/code>。&lt;/p>
&lt;ul>
&lt;li>&lt;code>__init__&lt;/code> 只是单纯的对实例进行某些属性的初始化，以及执行一些需要在新建对象时的必要自定义操作，无返回值。而 &lt;code>__new__&lt;/code> 返回的是用户创建的实例，这个才是真正用来创建实例的，所以 &lt;code>__new__&lt;/code> 是在 &lt;code>__init__&lt;/code> 之前执行的，先创建再初始化。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Python 2 和 Python 3 有哪些区别？&lt;/em>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html">http://sebastianraschka.com/Articles/2014_python_2_3_key_diff.html&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>连接字符串都有哪些方式？&lt;/p>
&lt;ul>
&lt;li>格式化字符连接（&lt;code>%s&lt;/code>)&lt;/li>
&lt;li>&lt;code>format&lt;/code>&lt;/li>
&lt;li>&lt;code>join&lt;/code>&lt;/li>
&lt;li>&lt;code>+&lt;/code>&lt;/li>
&lt;li>fstring&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>如何判断某个对象是什么类型？&lt;/p>
&lt;ul>
&lt;li>&lt;code>type(obj)&lt;/code>&lt;/li>
&lt;li>&lt;code>isinstance(obj, x)&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>生成器是什么？&lt;/em>&lt;/p>
&lt;ul>
&lt;li>一言难尽，推荐看这个 &lt;a href="https://taizilongxu.gitbooks.io/stackoverflow-about-python/content/1/README.html">stackoverflow 答案的翻译&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Python 中的 GIL 是什么？全称？举个例子说说其具体体现。&lt;/p>
&lt;ul>
&lt;li>GIL 全称 Global Interpreter Lock（全局解释器锁），任何 Python 线程执行前，必须先获得 GIL 锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。要避免这种“现象”利用操作系统的多核优势可以有下面几种方法：
&lt;ul>
&lt;li>使用 C 语言编写扩展，创建原生线程，摆脱 GIL，但是即使是扩展，在 Python 代码内，任意一条Python 代码还是会有 GIL 限制&lt;/li>
&lt;li>使用多进程代替多线程，使用多进程时，每个进程都有自己的 GIL。故不存在进程与进程之间的 GIL 限制。但是多进程不能共享内存。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>s = 'abcd', s[2] = 'e'&lt;/code> 运行结果是什么？&lt;/p>
&lt;ul>
&lt;li>报错，字符串是不可变对象&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Python 中，&lt;code>sorted&lt;/code> 函数内部是什么算法？&lt;/p>
&lt;ul>
&lt;li>在 &lt;a href="https://docs.python.org/3/howto/sorting.html?highlight=Timsort">官方文档&lt;/a> 里面有提到，用的是 &lt;a href="https://en.wikipedia.org/wiki/Timsort">Timsort&lt;/a> 算法&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>编码是一个什么样的过程？&lt;/p>
&lt;ul>
&lt;li>编码是二进制到字符的过程&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Python 里面怎么实现协程？&lt;/em>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://mp.weixin.qq.com/s/TKrb0i5fF0pJdRIgGC9qQQ">说清道明：协程是什么&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;code>requests&lt;/code> 包新建一个 &lt;code>session&lt;/code> 再 &lt;code>get&lt;/code> 和普通的 &lt;code>requests.get&lt;/code> 有什么区别？（tcp长连接）&lt;/p>
&lt;ul>
&lt;li>维持一个会话，** 建立一个tcp长连接** ，cookie 自动保存，下次请求还是一个会话。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>Python 都有哪些数据结构？可变对象，不可变对象分别有哪些？&lt;/em>&lt;/p>
&lt;ul>
&lt;li>可变对象：列表，字典&lt;/li>
&lt;li>不可变对象：字符串，数字，元组，集合&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>在 Python 内，函数传参是引用传递还是值传递？&lt;/em>&lt;/p>
&lt;ul>
&lt;li>引用传递。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>你会对你的项目写测试么？用哪些方法哪些库？&lt;/p>
&lt;ul>
&lt;li>doctest&lt;/li>
&lt;li>pytest&lt;/li>
&lt;li>unitest&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>请新建一个只有一个元素 &lt;code>1&lt;/code> 的列表和元组。&lt;/p>
&lt;ul>
&lt;li>&lt;code>lst = [1]&lt;/code>&lt;/li>
&lt;li>&lt;code>tup = (1,)&lt;/code>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>函数默认参数是可变对象情况。&lt;/em>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">foo&lt;/span>(a, b&lt;span style="color:#f92672">=&lt;/span>[&lt;span style="color:#ae81ff">1&lt;/span>, &lt;span style="color:#ae81ff">2&lt;/span>]):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b&lt;span style="color:#f92672">.&lt;/span>append(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> val &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">4&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> foo(val)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [1, 2]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [1, 2, 4]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">&amp;gt;&amp;gt;&amp;gt;&lt;/span> foo(val)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [1, 2, 4]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># [1, 2, 4, 4]&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 这里可以看到，第二次执行函数时，默认参数 b 的值已经变成 `[1, 2, 4]` 了，原因是，默认参数只在第&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 一次执行时会进行初始化，后面就默认使用 **初始化后的这个对象(引用)**，但是这里 b 是可变对象，&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e">#添加了一个元素还是之前的对象，所以，引用没变，不过是值变了而已。&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>&lt;em>Flask 的 Route 是怎么实现的？&lt;/em> 你认为 Flask 框架有什么优缺点？&lt;/p>
&lt;ul>
&lt;li>实际上在 Flask 类里面，&lt;code>route&lt;/code> 可以简单理解为不过是把对应的路由规则作为键，装饰的视图函数作为值，存到 &lt;code>werkzeug.routing.Map&lt;/code> 对象（可以看成是和字典类似的数据结构）里。这里是 &lt;a href="https://github.com/pallets/flask/blob/master/flask/app.py#L1076-L1120">源码&lt;/a>，好理解些。这是之前写的一篇 &lt;a href="https://github.com/x1ah/Blog/issues/4">笔记&lt;/a>&lt;/li>
&lt;li>Flask 优点是轻量，灵活，可高度定制，插件化。缺点也是过于轻量，功能必须通过第三方插件实现，插件质量参差不齐，也不能完全保证后期维护。&lt;/li>
&lt;li>这几点都只是个人之见，更详细标准的还需自行寻找答案。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>WSGI 是什么？uWSGI， nginx 这些都是什么用途？&lt;/em>&lt;/p>
&lt;ul>
&lt;li>这里有&lt;a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BD%91%E5%85%B3%E6%8E%A5%E5%8F%A3">维基百科&lt;/a> 的解释，WSGI 就是一个通用的标准，遵守这个标准，我们能让我们的 Web 框架更加通用，编写更加简单。&lt;/li>
&lt;li>uwsgi 和 Nginx 都是 Web Server，不同的是 Nginx 负责 外网请求 &amp;mdash;(转换)&amp;ndash;&amp;gt; 内网请求，uwsgi 负责的是 内网请求 -&amp;gt; Python Web 程序。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>nginx 和 Apache 的区别？(参考 &lt;a href="https://github.com/taizilongxu/interview_python#7-apache%E5%92%8Cnginx%E7%9A%84%E5%8C%BA%E5%88%AB">interview_python&lt;/a>)&lt;/p>
&lt;ul>
&lt;li>nginx 相对 apache 的优点：
&lt;ul>
&lt;li>轻量级，同样起web 服务，比apache 占用更少的内存及资源&lt;/li>
&lt;li>抗并发，nginx 处理请求是异步非阻塞的，支持更多的并发连接，而apache 则是阻塞型的，在高并发下nginx 能保持低资源低消耗高性能&lt;/li>
&lt;li>配置简洁&lt;/li>
&lt;li>高度模块化的设计，编写模块相对简单&lt;/li>
&lt;li>社区活跃&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>apache 相对nginx 的优点：
&lt;ul>
&lt;li>rewrite ，比nginx 的rewrite 强大&lt;/li>
&lt;li>模块超多，基本想到的都可以找到&lt;/li>
&lt;li>少bug ，nginx 的bug 相对较多&lt;/li>
&lt;li>超稳定&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>你部署 Python 项目时用的是 uWSGI 的哪个模式？&lt;/p>
&lt;ul>
&lt;li>默认模式&lt;/li>
&lt;li>这个应该问的可能性极小了，可翻阅 &lt;a href="http://uwsgi-docs-cn.readthedocs.io/zh_CN/latest/WSGIquickstart.html">uwsgi 文档&lt;/a> 查找更详细的资料&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="数据结构算法">数据结构，算法&lt;/h1>
&lt;ul>
&lt;li>层次遍历二叉树用什么方法？&lt;/li>
&lt;/ul>
&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># coding: utf-8&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> collections &lt;span style="color:#f92672">import&lt;/span> deque
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">BNode&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34; 二叉树节点 &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __init__(self, value, left&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">None&lt;/span>, right&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>value &lt;span style="color:#f92672">=&lt;/span> value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>left &lt;span style="color:#f92672">=&lt;/span> left
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>right &lt;span style="color:#f92672">=&lt;/span> right
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">level_traverse&lt;/span>(binary_tree):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34; 层次遍历二叉树 &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack &lt;span style="color:#f92672">=&lt;/span> deque([binary_tree])
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> stack:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> top &lt;span style="color:#f92672">=&lt;/span> stack&lt;span style="color:#f92672">.&lt;/span>popleft()
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> print(top&lt;span style="color:#f92672">.&lt;/span>value)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> top&lt;span style="color:#f92672">.&lt;/span>left:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#f92672">.&lt;/span>append(top&lt;span style="color:#f92672">.&lt;/span>left)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> top&lt;span style="color:#f92672">.&lt;/span>right:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> stack&lt;span style="color:#f92672">.&lt;/span>append(top&lt;span style="color:#f92672">.&lt;/span>right)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">if&lt;/span> __name__ &lt;span style="color:#f92672">==&lt;/span> &lt;span style="color:#e6db74">&amp;#34;__main__&amp;#34;&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> b_tree &lt;span style="color:#f92672">=&lt;/span> BNode(&lt;span style="color:#ae81ff">1&lt;/span>, BNode(&lt;span style="color:#ae81ff">2&lt;/span>, BNode(&lt;span style="color:#ae81ff">4&lt;/span>, BNode(&lt;span style="color:#ae81ff">5&lt;/span>, BNode(&lt;span style="color:#ae81ff">7&lt;/span>)))), BNode(&lt;span style="color:#ae81ff">3&lt;/span>, BNode(&lt;span style="color:#ae81ff">6&lt;/span>, right&lt;span style="color:#f92672">=&lt;/span>BNode(&lt;span style="color:#ae81ff">8&lt;/span>))))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> level_traverse(b_tree)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>非平衡二叉数如何变成平衡二叉数？&lt;/p>
&lt;ul>
&lt;li>参考 &lt;a href="https://segmentfault.com/a/1190000006123188">AVL平衡二叉树详解与实现&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>先，中，后序遍历二叉数。完全二叉数是什么？&lt;/p>
&lt;ul>
&lt;li>完全二叉树：深度为k有n个节点的二叉树，当且仅当其中的每一节点，都可以和同样深度k的满二叉树，序号为1到n的节点一对一对应时，称为“完全二叉树”。（摘自维基百科）&lt;/li>
&lt;li>先序：先根后左再右&lt;/li>
&lt;li>中序：先左后中再右&lt;/li>
&lt;li>后序：先左后右再根&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>如何判断两个单链表是否相交于某个节点，包括 X 型，Y 型，V 型。&lt;/p>
&lt;ul>
&lt;li>X 型不可能存在，一个单链表节点不存在两个不同的后继。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 存在 V 型和 Y 型，如果交叉，则最后一个节点肯定是相同的，故直接从最后一个节点进行反向遍历。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 反转单链表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">reverse_single_link_lst&lt;/span>(link_lst):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> &lt;span style="color:#f92672">not&lt;/span> link_lst:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> link_lst
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pre &lt;span style="color:#f92672">=&lt;/span> link_lst
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur &lt;span style="color:#f92672">=&lt;/span> link_lst&lt;span style="color:#f92672">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pre&lt;span style="color:#f92672">.&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> cur:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> tmp &lt;span style="color:#f92672">=&lt;/span> cur&lt;span style="color:#f92672">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur&lt;span style="color:#f92672">.&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> pre
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> pre &lt;span style="color:#f92672">=&lt;/span> cur
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> cur &lt;span style="color:#f92672">=&lt;/span> tmp
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> pre
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 寻找交叉点&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">point&lt;/span>(node_a, node_b):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> node_a &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span> &lt;span style="color:#f92672">or&lt;/span> node_b &lt;span style="color:#f92672">is&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next_a, next_b &lt;span style="color:#f92672">=&lt;/span> node_a, node_b
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> next_a &lt;span style="color:#f92672">or&lt;/span> next_b:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> next_a&lt;span style="color:#f92672">.&lt;/span>val &lt;span style="color:#f92672">==&lt;/span> next_b&lt;span style="color:#f92672">.&lt;/span>val:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> next_a&lt;span style="color:#f92672">.&lt;/span>next &lt;span style="color:#f92672">and&lt;/span> next_b&lt;span style="color:#f92672">.&lt;/span>next &lt;span style="color:#f92672">and&lt;/span> (next_a&lt;span style="color:#f92672">.&lt;/span>next&lt;span style="color:#f92672">.&lt;/span>val &lt;span style="color:#f92672">==&lt;/span> next_b&lt;span style="color:#f92672">.&lt;/span>next&lt;span style="color:#f92672">.&lt;/span>val):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next_a, next_b &lt;span style="color:#f92672">=&lt;/span> next_a&lt;span style="color:#f92672">.&lt;/span>next, next_b&lt;span style="color:#f92672">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">continue&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> next_a&lt;span style="color:#f92672">.&lt;/span>val
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> next_a, next_b &lt;span style="color:#f92672">=&lt;/span> next_a&lt;span style="color:#f92672">.&lt;/span>next, next_b&lt;span style="color:#f92672">.&lt;/span>next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">None&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 构造单链表&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">class&lt;/span> &lt;span style="color:#a6e22e">Node&lt;/span>(object):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> __init__(self, value, next&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#66d9ef">None&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>val &lt;span style="color:#f92672">=&lt;/span> value
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> self&lt;span style="color:#f92672">.&lt;/span>next &lt;span style="color:#f92672">=&lt;/span> next
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>a &lt;span style="color:#f92672">=&lt;/span> ListNode(&lt;span style="color:#ae81ff">1&lt;/span>, ListNode(&lt;span style="color:#ae81ff">2&lt;/span>, ListNode(&lt;span style="color:#ae81ff">3&lt;/span>, ListNode(&lt;span style="color:#ae81ff">4&lt;/span>, ListNode(&lt;span style="color:#ae81ff">5&lt;/span>)))))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>b &lt;span style="color:#f92672">=&lt;/span> ListNode(&lt;span style="color:#ae81ff">7&lt;/span>, ListNode(&lt;span style="color:#ae81ff">9&lt;/span>, ListNode(&lt;span style="color:#ae81ff">4&lt;/span>, ListNode(&lt;span style="color:#ae81ff">5&lt;/span>))))
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>ra &lt;span style="color:#f92672">=&lt;/span> reverse_single_link_lst(a)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>rb &lt;span style="color:#f92672">=&lt;/span> reverse_single_link_lst(b)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>point(ra, rb)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># output:&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 4&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>
&lt;p>如何判断两个单链表是否是同一个链表。&lt;/p>
&lt;ul>
&lt;li>直接判断第一个节点即可。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>单链表逆转。&lt;/p>
&lt;ul>
&lt;li>见上面判断交叉链表内的 &lt;code>reverse_single_link_lst()&lt;/code> 函数。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>堆，栈，队列。&lt;/em>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E5%A0%86_(%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84)">堆&lt;/a>， &lt;a href="https://zh.wikipedia.org/zh-hans/%E5%A0%86%E6%A0%88">栈&lt;/a>， &lt;a href="https://zh.wikipedia.org/wiki/%E9%98%9F%E5%88%97">队列&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>说说你知道的排序算法以及其时间复杂度。&lt;/em>
&lt;img src="http://ww1.sinaimg.cn/large/005NaGmtly1fenoomcn03j30iz07874f.jpg" alt="">&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;em>手写快速排序。画画堆排序的原理及过程。&lt;/em>&lt;/p>
&lt;/li>
&lt;/ul>
&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 快速排序，lz 当时写的比较复杂，但是是最常见的写法（紧张导致有几个小bug），如下&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">quick_sort&lt;/span>(lst, start, stop):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> start &lt;span style="color:#f92672">&amp;lt;&lt;/span> stop:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i, j, x &lt;span style="color:#f92672">=&lt;/span> start, stop, lst[start]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> j:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (i &lt;span style="color:#f92672">&amp;lt;&lt;/span> j) &lt;span style="color:#f92672">and&lt;/span> (lst[j] &lt;span style="color:#f92672">&amp;gt;&lt;/span> x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">&amp;lt;&lt;/span> j):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lst[i] &lt;span style="color:#f92672">=&lt;/span> lst[j]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> (i &lt;span style="color:#f92672">&amp;lt;&lt;/span> j) &lt;span style="color:#f92672">and&lt;/span> (lst[i] &lt;span style="color:#f92672">&amp;lt;&lt;/span> x):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> (i &lt;span style="color:#f92672">&amp;lt;&lt;/span> j):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lst[j] &lt;span style="color:#f92672">=&lt;/span> lst[i]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> j &lt;span style="color:#f92672">-=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> lst[i] &lt;span style="color:#f92672">=&lt;/span> x
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> quick_sort(lst, start, i&lt;span style="color:#f92672">-&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> quick_sort(lst, i&lt;span style="color:#f92672">+&lt;/span>&lt;span style="color:#ae81ff">1&lt;/span>, stop)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> lst
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>之后面试官 &lt;a href="https://github.com/akun">akun&lt;/a> 大哥给了个特别简洁的写法，三路复用，地址在 &lt;a href="https://gist.github.com/akun/d90998068f4e1f3eb169">Gist&lt;/a>&lt;/p>
&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">qsort&lt;/span>(alist):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#e6db74">&amp;#34;&amp;#34;&amp;#34;
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> quick sort(easy way, but more memory)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> test: python -m doctest qsort.py
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;gt;&amp;gt;&amp;gt; import math
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;gt;&amp;gt;&amp;gt; import random
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;gt;&amp;gt;&amp;gt; size = 100
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;gt;&amp;gt;&amp;gt; alist = [random.randint(0, size * 10) for i in range(size)]
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;gt;&amp;gt;&amp;gt; qlist = qsort(alist)
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;gt;&amp;gt;&amp;gt; alist.sort()
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;gt;&amp;gt;&amp;gt; assert qlist == alist
&lt;/span>&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#e6db74"> &amp;#34;&amp;#34;&amp;#34;&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">if&lt;/span> len(alist) &lt;span style="color:#f92672">&amp;lt;=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> alist
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> key &lt;span style="color:#f92672">=&lt;/span> alist[&lt;span style="color:#ae81ff">0&lt;/span>]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> left_list, middle_list, right_list &lt;span style="color:#f92672">=&lt;/span> [], [], []
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> [{i &lt;span style="color:#f92672">&amp;lt;&lt;/span> key: left_list, i &lt;span style="color:#f92672">==&lt;/span> key: middle_list, i &lt;span style="color:#f92672">&amp;gt;&lt;/span> key: right_list}[
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> ]&lt;span style="color:#f92672">.&lt;/span>append(i) &lt;span style="color:#66d9ef">for&lt;/span> i &lt;span style="color:#f92672">in&lt;/span> alist]
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> qsort(left_list) &lt;span style="color:#f92672">+&lt;/span> middle_list &lt;span style="color:#f92672">+&lt;/span> qsort(right_list)
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>说说你所了解的加密算法，编码算法，以及压缩算法。了解 base64 的原理么？
&lt;ul>
&lt;li>只说了听过 base64, md5 这几种编码。。。。。自行搜索吧，考的概率极小。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="数据库">数据库&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>索引是什么原理？有什么优缺点？&lt;/p>
&lt;ul>
&lt;li>参考 &lt;a href="http://blog.csdn.net/kennyrose/article/details/7532032">数据库索引的实现原理&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>乐观锁和悲观锁是什么？&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.hollischuang.com/archives/934">深入理解乐观锁与悲观锁&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>你为什么选择 Redis 而不是 MongoDB 或者其他的？（有个项目用了 Redis）&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://segmentfault.com/q/1010000002588088/a-1020000002589415">redis、memcache、mongoDB有哪些区别？&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>SQL 和 NoSQL 区别？&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.jianshu.com/p/b32fe4fe45a3">SQL 和 NoSQL 的区别&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="网络">网络&lt;/h1>
&lt;ul>
&lt;li>
&lt;p>从浏览器输入网址到网页渲染完毕这过程发生了什么？&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://github.com/skyline75489/what-happens-when-zh_CN">这里&lt;/a> 说的非常详细，看面的岗位不同，回答的侧重点不一样。如面的 Web ，可以侧重说说 nginx -&amp;gt; uwsgi -&amp;gt; Python -&amp;gt; uwsgi -&amp;gt; nginx 这个过程，（WSGI 标准）&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>TCP 三次握手四次挥手详细说下。&lt;/em>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://blog.csdn.net/whuslei/article/details/6667471">TCP协议中的三次握手和四次挥手(图解)&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>为什么是三次握手？两次不行么？&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://www.cnblogs.com/techzi/archive/2011/10/18/2216751.html">TCP连接建立过程中为什么需要“三次握手”&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>说说 TCP 和 UDP 的区别。&lt;/em>&lt;/p>
&lt;ul>
&lt;li>TCP（传输层）
&lt;ul>
&lt;li>优点：TCP 面向连接，可靠，稳定，传输数据前需要建立连接，故有三次握手四次挥手，还有拥塞控制，重传等&lt;/li>
&lt;li>缺点：慢，占用系统资源，有确认机制，三次握手，所以容易被攻击，DDos&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>UDP
&lt;ul>
&lt;li>优点：快，无状态传输协议&lt;/li>
&lt;li>缺点：不稳定，不可靠，容易丢包&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>谈谈你对 SQL 注入、 XSS 、 CSRF 的理解。以及如何防范。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://cnodejs.org/topic/50463565329c5139760c34a1">关于XSS（跨站脚本攻击）和CSRF（跨站请求伪造)&lt;/a>&lt;/li>
&lt;li>&lt;a href="https://zh.m.wikipedia.org/zh-hans/SQL%E8%B3%87%E6%96%99%E9%9A%B1%E7%A2%BC%E6%94%BB%E6%93%8A">SQL 注入&lt;/a>，现在多数采用 ORM，以及参数化查询，很少再出现。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>说说 DNS 是什么东西。&lt;/em>&lt;/p>
&lt;ul>
&lt;li>根据域名寻找 主机 IP 的协议。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>HTTP 是工作在七层模型的哪一层？DNS 又是哪一层？TCP 和 IP 呢？&lt;/p>
&lt;ul>
&lt;li>HTTP，DNS 应用层，TCP 传输层，IP 网络层。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>说说你知道的 HTTP 方法和 状态码。&lt;/em>&lt;/p>
&lt;ul>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81">状态码&lt;/a>，这里只需要大概说说，以 1××，2××，3×× 这样的层面说，没有必要细到每一个状态码。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#.E8.AF.B7.E6.B1.82.E6.96.B9.E6.B3.95">HTTP 请求方法&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>HTTP 的 GET 和 POST 有什么区别？&lt;/em>&lt;/p>
&lt;ul>
&lt;li>本质上，GET 和 POST 只不过是 &lt;strong>发送机制不同&lt;/strong> 。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>HTTP 和 HTTPS 的区别？&lt;/p>
&lt;ul>
&lt;li>HTTPS = HTTP + SSL&lt;/li>
&lt;li>HTTP 默认使用 80 端口，HTTPS 使用 443 端口。&lt;/li>
&lt;li>&lt;a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%AE%89%E5%85%A8%E5%8D%8F%E8%AE%AE#.E4.B8.8EHTTP.E7.9A.84.E5.B7.AE.E5.BC.82">更详细&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>说说你知道的 HTTP 包头部信息里都有哪些字段。&lt;/p>
&lt;ul>
&lt;li>这个随便抓下包就知道了，就不说了～&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>&lt;em>HTTP 包头部信息里面的 &lt;code>Host&lt;/code> 字段是什么作用？&lt;/em>&lt;/p>
&lt;ul>
&lt;li>表示当前请求服务器的主机名&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>说说 cookie 里面你都知道哪些字段。&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://javascript.ruanyifeng.com/bom/cookie.html">Cookie&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Session 是什么东西？&lt;/p>
&lt;ul>
&lt;li>&lt;a href="http://harttle.com/2015/08/10/cookie-session.html">Cookie/Session的机制与安全&lt;/a>&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>在写爬虫过程中，如果遇见需要加载 js 的情况你是如何处理的。&lt;/p>
&lt;ul>
&lt;li>Selenium，PhantomJS&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>普通匿名代理和高匿代理有什么区别？&lt;/p>
&lt;ul>
&lt;li>来自普通匿名代理的请求在服务端能看见真实 IP， 而高匿代理在服务端看不见真实 IP，只能看见代理服务器 IP。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>你知道哪些反爬措施？&lt;/p>
&lt;ul>
&lt;li>加代理，加头部，爬取速度控制，随机 UA，模拟真实用户的点击习惯去请求。&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h1 id="操作系统">操作系统&lt;/h1>
&lt;ul>
&lt;li>&lt;em>进程和线程以及协程的区别？&lt;/em>&lt;/li>
&lt;li>&lt;em>多线程和多进程的区别？&lt;/em>&lt;/li>
&lt;li>信号量和互斥量的区别？&lt;/li>
&lt;li>堆内存是干嘛的？&lt;/li>
&lt;li>如何检验当前机器是大端模式还是小端模式？&lt;/li>
&lt;li>如何让某个程序在后台运行？（Linux）&lt;/li>
&lt;li>sed, awk 用法（Linux）&lt;/li>
&lt;/ul>
&lt;h1 id="编程题">编程题&lt;/h1>
&lt;ul>
&lt;li>手写二分查找，&lt;em>快速排序&lt;/em>。&lt;/li>
&lt;li>~还有一个 SQL 语句的，一条 SQL 语句打印某张表某个 group count TOP 5。~&lt;/li>
&lt;li>Python 中正则模块 &lt;code>re&lt;/code> 里 &lt;code>match&lt;/code> 函数 和 &lt;code>search&lt;/code> 函数有什么区别？举例说明。&lt;/li>
&lt;li>一条语句求 0 - 999999 内能被 7 整除的所有数的和。&lt;/li>
&lt;li>实现一个链表结构，要求其插入第一个节点，删除最后一个节点的复杂度为 O(1)。&lt;/li>
&lt;li>实现一个 &lt;code>retry&lt;/code> 装饰器，使用如下：&lt;/li>
&lt;/ul>
&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#75715e"># 可以指定重试次数，直到函数返回正确结果。&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#a6e22e">@retry&lt;/span>(retries&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">func&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>args, &lt;span style="color:#f92672">**&lt;/span>kw):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">try&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#75715e"># some action&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">except&lt;/span>:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> &lt;span style="color:#66d9ef">False&lt;/span>
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>大概可以像下面这样写，&lt;/p>
&lt;hr>
&lt;div class="highlight">&lt;pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;">&lt;code class="language-python" data-lang="python">&lt;span style="display:flex;">&lt;span>&lt;span style="color:#f92672">from&lt;/span> functools &lt;span style="color:#f92672">import&lt;/span> wraps
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span>&lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">retry&lt;/span>(retries&lt;span style="color:#f92672">=&lt;/span>&lt;span style="color:#ae81ff">3&lt;/span>):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">timesf&lt;/span>(func):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#a6e22e">@wraps&lt;/span>(func)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">def&lt;/span> &lt;span style="color:#a6e22e">wrap&lt;/span>(&lt;span style="color:#f92672">*&lt;/span>args, &lt;span style="color:#f92672">**&lt;/span>kw):
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#ae81ff">0&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#f92672">=&lt;/span> &lt;span style="color:#66d9ef">True&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">while&lt;/span> status &lt;span style="color:#f92672">and&lt;/span> i &lt;span style="color:#f92672">&amp;lt;&lt;/span> times:
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> status &lt;span style="color:#f92672">=&lt;/span> func(&lt;span style="color:#f92672">*&lt;/span>args, &lt;span style="color:#f92672">**&lt;/span>kw)
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> i &lt;span style="color:#f92672">+=&lt;/span> &lt;span style="color:#ae81ff">1&lt;/span>
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> status
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> wrap
&lt;/span>&lt;/span>&lt;span style="display:flex;">&lt;span> &lt;span style="color:#66d9ef">return&lt;/span> timesf
&lt;/span>&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;ul>
&lt;li>有一个4G 的文本文件，存储的是酒店信息，每行存的是一个酒店ID，可以重复。请编写程序输出一个新文件，新文件内容为每行一条数据，每行的数据格式如下：&lt;code>酒店ID + 出现次数&lt;/code>（最后提到了其他想法，如文件切片，bitmap 之类）&lt;/li>
&lt;li>实现一个函数，根据字典序比较两字符串大小，不允许用库函数，尽量越底层实现越好。（手写）&lt;/li>
&lt;li>实现一个函数，检验一个字符串是否符合 &lt;code>xxxx-xx-xx&lt;/code> 这样的日期格式，注意润年，大小月，不允许用库函数，尽量越底层实现越好。（手写）&lt;/li>
&lt;li>我们是做地图相关工作的，现在给你提供一个三维的数据，数据描述的是不同时间一些地图上的一些地点坐标，分别有时间，x轴坐标，y轴坐标，请你设计一个算法，能够得到一天内地图上的 TOP 10 热点地区，地区大小也相应的自己作合适调整，开放性题目。&lt;/li>
&lt;/ul>
&lt;h1 id="概率论">概率论&lt;/h1>
&lt;ul>
&lt;li>一副扑克除去大小王，共 52 张排，随机取三张扑克，求同花（三张扑克同一种花色）和顺子的概率。&lt;/li>
&lt;li>其他忘了 Orz&lt;/li>
&lt;/ul>
&lt;hr>
&lt;blockquote>
&lt;p>原文：https://github.com/x1ah/Blog/issues/9&lt;/p>
&lt;/blockquote></content></item></channel></rss>