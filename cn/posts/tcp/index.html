<!doctype html><html lang=cn><head><title>TCP 札记 :: x1ah</title>
<meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="TCP 札记"><meta name=keywords content="TCP"><meta name=robots content="noodp"><link rel=canonical href=https://when.run/cn/posts/tcp/><script async src="https://www.googletagmanager.com/gtag/js?id=G-21PQZQT56W"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-21PQZQT56W",{anonymize_ip:!1})}</script><link rel=stylesheet href=https://when.run/assets/style.css><link rel=apple-touch-icon href=https://when.run/img/apple-touch-icon-192x192.png><link rel="shortcut icon" href=https://when.run/avator.jpeg><meta name=twitter:card content="summary"><meta property="og:locale" content="cn"><meta property="og:type" content="article"><meta property="og:title" content="TCP 札记"><meta property="og:description" content="TCP 札记"><meta property="og:url" content="https://when.run/cn/posts/tcp/"><meta property="og:site_name" content="x1ah"><meta property="og:image" content="https://when.run/"><meta property="og:image:width" content="2048"><meta property="og:image:height" content="1024"><meta property="article:published_time" content="2020-02-10 00:00:00 +0000 UTC"><script async src="https://www.googletagmanager.com/gtag/js?id=G-21PQZQT56W"></script><script>var doNotTrack=!1;if(!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-21PQZQT56W",{anonymize_ip:!1})}</script></head><body class=orange><div class="container center headings--one-size"><header class=header><div class=header__inner><div class=header__logo><a href=/><div class=logo>x1ah</div></a></div><div class=menu-trigger>menu</div></div><nav class=menu><ul class="menu__inner menu__inner--desktop"><li><a href=/cn/about/>About</a></li><li><a href=/cn/index.xml>RSS</a></li></ul><ul class="menu__inner menu__inner--mobile"><li><a href=/cn/about/>About</a></li><li><a href=/cn/index.xml>RSS</a></li></ul></nav></header><div class=content><div class=post><h1 class=post-title><a href=https://when.run/cn/posts/tcp/>TCP 札记</a></h1><div class=post-meta><span class=post-date>2020-02-10
</span><span class=post-author>:: x1ah</span></div><span class=post-tags>#<a href=https://when.run/cn/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/>计算机网络</a>&nbsp;</span><div class=post-content><div><blockquote><p>TCP 处于七层网络模型（应表会传网数物）中的传输层。</p></blockquote><h2 id=特点>特点<a href=#特点 class=hanchor arialabel=Anchor>&#8983;</a></h2><h3 id=面向连接>面向连接<a href=#面向连接 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>和 UDP 不一样，TCP 传输数据前需要先建立 TCP 连接（此处引出三次握手、四次挥手）。而 UDP 传输数据前不需要建立连接，也不保证可靠传输。</p><h3 id=可靠传输>可靠传输<a href=#可靠传输 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>TCP 保证传输的数据：无差错、不丢失、不重复、 <strong>按序到达</strong> 。</p><h3 id=全双工>全双工<a href=#全双工 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>通信双方任何时候都能相互通信。并且都有发送缓存、接受缓存。</p><h3 id=面向字节流>面向字节流<a href=#面向字节流 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>虽然应用层和 TCP 的交互是一次一个数据块（大小不等），但是 TCP 把这些数据看成仅仅是一连串的无结构字节流。TCP 并不知道所传送的字节流的含义。传输过程如下：</p><p><img alt="tcp 面向流的概念" src=/image/tcp_stream.jpg></p><p>这里看到，应用层发送其实不是同步发送的，而只是把数据拷到 TCP 发送缓存里，而下一步如何发送，如何把数据切成报文段，都与应用层无关了。</p><p>基于这个字节流传输概念，对于偶尔能听到的 “黏包” 概念也能较为直接的解释。因为 TCP 并没有包的概念，因此自然也就不存在 “黏包” <a href=https://draveness.me/whys-the-design-tcp-message-frame/>为什么 TCP 协议有粘包问题</a>。&ldquo;黏包&rdquo; 误解的原因是：&ldquo;应用层协议没有使用基于长度或者基于终结符的消息边界，导致多个消息的粘连&rdquo;</p><h2 id=报文段字节流>报文段、字节流<a href=#报文段字节流 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>TCP 存在一个 “报文段” 的概念，这个指的是：在 TCP 接收到应用层写入的数据之后，会暂存到发送缓存。而 TCP 在发送数据之前，会从发送缓存中取出一部分数据，并且加上 TCP 层的特定头部数据，再往下传输给 IP 层，加上了 TCP 头部的这部分数据，叫做 TCP 的 “报文段”，这个报文段的最大长度叫做 <em><strong>MSS（最大报文段长度）</strong></em>。而在传输时，报文段会被以字节流的形式进行传输，接收方收到字节流之后，再解析字节流还原成报文段，交付使用。</p><h2 id=可靠传输滑动窗口>可靠传输（滑动窗口）<a href=#可靠传输滑动窗口 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>TCP 使用 <strong>滑动窗口</strong> 来实现可靠传输。TCP 的滑动窗口是以字节为单位的，并对窗口内的字节进行编号，如果窗口内某个低序号的字节未收到确认消息，那么滑动窗口将不会往后移，而会在确认超时之后，重新传送，即 <strong>超时重传</strong>。这时候，就有可能出现，一条 TCP 链接，某个时刻发生了超时重传，其他数据必须等这个重传恢复之后，才能继续发送。而 HTTP/3 使用的 QUIC 协议使用了多路流复用，同一个传输通道可以同时传输多路流，而不同流也使用不同的流量控制、滑动窗口等，这样即使某一路的流阻塞了，也不会影响其他路的流。</p><h2 id=流量控制>流量控制<a href=#流量控制 class=hanchor arialabel=Anchor>&#8983;</a></h2><p><strong>流量控制（flow control）</strong> 的作用是让发送方的发送速率不要太快，要让接收方来得及接受。</p><p>当 TCP 端点 A 向 TCP 端点 B 发送数据时，整个过程会出现两个滑动窗口，A 的发送窗口和 B 的接收窗口。当 B 感受到压力过大，或者其他原因需要进行流控时，会给发送方发送消息，告知发送方 <strong>接收窗口(rwnd)</strong> 的大小，发送方根据这个数值，调整发送窗口的大小。利用滑动窗口机制可以方便的在 TCP 连接上实现对发送方的流量控制。</p><h2 id=拥塞控制>拥塞控制<a href=#拥塞控制 class=hanchor arialabel=Anchor>&#8983;</a></h2><p>当网络阻塞，例如：链路传输速率只有 10Gb/s ，但是有 100 台计算机，同时以 1Gb/s 的速率传输，这时候就会发生拥塞，导致网络性能变坏，因此需要拥塞控制，防止过多的数据注入到网络中，避免网络中的路由器或者链路过载。拥塞控制有四种算法：<strong>慢开始（slow-start）</strong>、<strong>拥塞避免（congestion avoidance）</strong>、<strong>快重传（fast retransmit）</strong>、<strong>快恢复（fast recovery）</strong>。 这里网络出现拥塞表现一般为：数据丢失，时延增加，吞吐量下降</p><h3 id=慢开始指数增大>慢开始（指数增大）<a href=#慢开始指数增大 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>发送方维护一个拥塞窗口，让发送窗口等于拥塞窗口。最开始把拥塞窗口设为 MSS 大小，每收到一个 ACK，就增加一个 MSS（这里可以看出来，没经过一个传输轮次，拥塞窗口就会加倍）。当拥塞窗口增加到 <strong>慢开始门限</strong> 之后，改用 <strong>拥塞避免算法</strong></p><h3 id=拥塞避免加法增大>拥塞避免（加法增大）<a href=#拥塞避免加法增大 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>不再每收到一个 ACK 就增加一个 MSS，而是每经过一个 RTT（把发送窗口都发送出去并收到 ACK），增加一个 MSS。当发送方判断网络出现拥塞时，把慢开始门限减为发送窗口的一半，并把拥塞窗口设为 1，重新开始慢开始流程</p><h3 id=快重传>快重传<a href=#快重传 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>首先要求接收方每接收到一个报文段，就发出重复确认，让发送方能尽快重传。接收方收到 3 个重复确认就应该开始重传对方未收到的报文段，而不是等待计时器过期。</p><h3 id=快恢复>快恢复<a href=#快恢复 class=hanchor arialabel=Anchor>&#8983;</a></h3><p>当发送方收到 3 个重复确认之后，把拥塞控制设置为慢开始门限的一半，然后开始执行拥塞控制算法（加法增大）</p><p>结合拥塞控制和流量控制，发送方的发送窗口值为 <code>min(拥塞窗口, 接收窗口)</code></p><h2 id=参考>参考<a href=#参考 class=hanchor arialabel=Anchor>&#8983;</a></h2><ul><li>计算机网络（第六版 谢希仁著）</li></ul></div></div><div class=pagination><div class=pagination__title><span class=pagination__title-h>其他文章</span><hr></div><div class=pagination__buttons><span class="button previous"><a href=https://when.run/cn/posts/keep-alive-chat/><span class=button__icon>←</span>
<span class=button__text>长连接聊天室 Demo</span>
</a></span><span class="button next"><a href=https://when.run/cn/posts/python2-to-python3/><span class=button__text>Python2 迁移到 Python3 规划和实施</span>
<span class=button__icon>→</span></a></span></div></div><script src=https://utteranc.es/client.js repo=x1ah/x1ah.github.io issue-term=pathname label=Comment theme=photon-dark crossorigin=anonymous async></script></div></div><footer class=footer><div class=footer__inner><div class=copyright><span>© 2024 Powered by <a href=http://gohugo.io>Hugo</a></span>
<span>:: Theme made by <a href=https://twitter.com/panr>panr</a></span></div></div></footer><script src=https://when.run/assets/main.js></script><script src=https://when.run/assets/prism.js></script></div></body></html>